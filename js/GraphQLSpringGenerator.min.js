class GraphQLSpringGenerator{constructor(){this.packageName=null,this.groupId=null,this.artifactId=null,this.serviceName=null,this.serviceDescription=null,this.javaVersion=null,this.version=null,this.maxRelationDepth=3,this.model=null}generateVirtualFiles(){let e={port:parseInt(document.querySelector("#appPort").value.trim(),10)},t={url:document.querySelector("#dbUrl").value.trim(),username:document.querySelector("#dbUsername").value.trim(),password:document.querySelector("#dbPassword").value,driver:document.querySelector("#dbDriver").value.trim(),showSql:"true"===document.querySelector("#dbShowSql").value,dialect:document.querySelector("#dbDialect").value.trim()},a=[];return a.push(...this.generateIdClassFiles()),a.push(...this.generateEntityFiles()),a.push(...this.generateRepositoryFiles()),a.push(...this.generateConnectionFiles()),a.push(...this.generateServiceFiles()),a.push(...this.generateControllerFiles()),a.push(...this.generateGraphQlSchema()),a.push(...this.generatePageInfoFile()),a.push(...this.generatePomFile()),a.push(...this.generateApplicationFile()),a.push(...this.generateCorsConfigFile()),a.push(...this.generateRequestInterceptorFile()),a.push(...this.generateDataFilterFile()),a.push(...this.generateDataOrderFile()),a.push(...this.generateFetchPropertiesFile()),a.push(...this.generateSpecificationUtilFile()),a.push(...this.generatePageUtilFile()),a.push(...this.generateApplicationPropertiesFile(e,t)),a.push(...Maven.generateMavenFile()),a.push(...Maven.generateMavenCmdFile()),a.push(...Maven.generateMavenWrapperFiles()),a}async createZipFile(e,t={},a="servicegen.zip"){this.packageName=t.packageName||"com.example.servicegen",this.groupId=t.groupId||"com.example",this.artifactId=t.artifactId||"servicegen",this.serviceName=t.serviceName||"Service Generator",this.serviceDescription=t.serviceDescription||"A service generator for Spring GraphQL",this.javaVersion=t.javaVersion||"21",this.version=t.version||"1.0.0",this.maxRelationDepth=3,this.model=e;let r=document.getElementById("loading");r.style.display="block";let i=this.generateVirtualFiles();if(0===i.length){alert("Tidak ada file untuk dikompresi."),r.style.display="none";return}let n=new JSZip;for(let o of i)n.file(o.name,o.content);try{let s=await n.generateAsync({type:"blob"});saveAs(s,a)}catch(p){console.error("Gagal membuat file ZIP:",p)}finally{r.style.display="none"}}getPrimaryKeys(e){return e.columns.filter(e=>e.primaryKey)}getPrimatyKey(e){let t=e.columns.find(e=>e.primaryKey);return t?{primaryKeyName:t.name,primaryKeyCamel:stringUtil.camelize(t.name),primaryKeyType:t.type,primaryKeyJavaType:this.getJavaType(t.type)}:null}getJavaType(e){let t=e.toLowerCase();if(-1!==t.indexOf("int")||-1!==t.indexOf("integer")||-1!==t.indexOf("tinyint")||-1!==t.indexOf("long")||-1!==t.indexOf("bigint"))return"Long";if(-1!==t.indexOf("string")||-1!==t.indexOf("varchar")||-1!==t.indexOf("text"))return"String";if(-1!==t.indexOf("boolean"))return"Boolean";if(-1!==t.indexOf("date")||-1!==t.indexOf("timestamp"))return"Date";else if(-1!==t.indexOf("double")||-1!==t.indexOf("float"))return"Double";else if(-1!==t.indexOf("uuid"))return"UUID";else if(-1!==t.indexOf("bigdecimal"))return"BigDecimal";else if(-1!==t.indexOf("number")||-1!==t.indexOf("real")||-1!==t.indexOf("decimal")||-1!==t.indexOf("numeric"))return"Double";return"Object"}createSourceDirectoryFromArtefact(e){return"src/main/java/"+e.split(".").join("/")+"/"}generateApplicationFile(){let e=`package ${this.packageName};

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"Application.java",content:e}]}generateApplicationPropertiesFile(e,t){let a=`# Spring Boot application properties
# Server port
server.port=${e.port||8080}
# Database configuration
spring.datasource.url=${t.url||"jdbc:mysql://localhost:3306/mydb"}
spring.datasource.username=${t.username||"root"}
spring.datasource.password=${t.password||""}
spring.datasource.driver-class-name=${t.driver||"com.mysql.cj.jdbc.Driver"}
# JPA/Hibernate configuration
spring.jpa.show-sql=${t.showSql||"true"}
spring.jpa.properties.hibernate.dialect=${t.dialect}
# GraphQL configuration
spring.graphql.schema-location=classpath:graphql/schema.graphqls
# Logging configuration
logging.level.org.springframework=INFO
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
# Application name and description
spring.application.name=${this.serviceName}
spring.application.description=${this.serviceDescription}
# Java version
spring.java.version=${this.javaVersion}
# Package name
spring.package.name=${this.packageName}
# Version
spring.application.version=${this.version}
`;return[{name:"src/main/resources/application.properties",content:a}]}generateRequestInterceptorFile(){let e=`package ${this.packageName}.config;

import java.util.Map;

import org.springframework.graphql.server.WebGraphQlInterceptor;
import org.springframework.graphql.server.WebGraphQlRequest;
import org.springframework.graphql.server.WebGraphQlResponse;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

@Component
public class GraphQLRequestInterceptor implements WebGraphQlInterceptor {

    @Override
    public Mono<WebGraphQlResponse> intercept(WebGraphQlRequest request, Chain chain) {
        // Get all headers
        Map<String, String> headers = request.getHeaders().toSingleValueMap();

        // Get IP address
        String clientIp = request.getRemoteAddress() != null
                ? request.getRemoteAddress().getAddress().getHostAddress()
                : "UNKNOWN";

        // Put it into GraphQLContext
        request.configureExecutionInput((executionInput, builder) ->
                builder.graphQLContext(Map.of(
                        "clientIp", clientIp,
                        "headers", headers
                )).build()
        );

        return chain.next(request);
    }
}

`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"config/GraphQLRequestInterceptor.java",content:e}]}generateCorsConfigFile(){let e=`package ${this.packageName}.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/graphql/**") 
                .allowedOrigins("*") 
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*");
    }
}`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"config/CorsConfig.java",content:e}]}generateControllerFiles(){let e=this.model.entities,t=[];return e.forEach(e=>{let a=e.name,r=stringUtil.camelize(a),i=stringUtil.upperCamel(r),n=this.getPrimaryKeys(e);if(n.length>0){let o=n.map(e=>`@Argument ${this.getJavaType(e.type)} ${stringUtil.camelize(e.name)}`).join(", "),s=n.map(e=>stringUtil.camelize(e.name)).join(", "),p=`package ${this.packageName}.controller;

import java.util.List;

import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.stereotype.Controller;


import ${this.packageName}.output.${i}Connection;
import ${this.packageName}.utils.DataFilter;
import ${this.packageName}.utils.DataOrder;
import ${this.packageName}.entity.${i};
import ${this.packageName}.entity.${i}Input;
import ${this.packageName}.service.${i}Service;

import graphql.schema.DataFetchingEnvironment;

import lombok.RequiredArgsConstructor;


@Controller
@RequiredArgsConstructor
public class ${i}Controller {

    private final ${i}Service ${r}Service;

    @QueryMapping
    public ${i}Connection get${i}s(@Argument(name = "pageNumber") Integer pageNumber, @Argument(name = "pageSize") Integer pageSize, @Argument(name = "dataFilter") List<DataFilter> dataFilter, @Argument(name = "dataOrder") List<DataOrder> dataOrder, DataFetchingEnvironment env) {
        return ${r}Service.get${i}s(pageNumber, pageSize, dataFilter, dataOrder);
    }

    @QueryMapping
    public ${i} get${i}(${o}, DataFetchingEnvironment env) {
        return ${r}Service.get${i}(${s});
    }

    @MutationMapping
    public ${i} create${i}(@Argument ${i}Input input, DataFetchingEnvironment env) {
        return ${r}Service.create${i}(input);
    }

    @MutationMapping
    public ${i} update${i}(@Argument ${i}Input input, DataFetchingEnvironment env) {
        return ${r}Service.update${i}(input);
    }

    @MutationMapping
    public Boolean delete${i}(${o}, DataFetchingEnvironment env) {
        ${r}Service.delete${i}(${s});
        return true;
    }
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`controller/${i}Controller.java`,content:p})}}),t}generateServiceFiles(){let e=this,t=this.model.entities,a=[];return t.forEach(t=>{let r=t.name,i=stringUtil.camelize(r),n=stringUtil.upperCamel(i),o=this.getPrimaryKeys(t),s="";t.columns.forEach(t=>{let a=e.getDataType(t.type),r=e.getFilterType(a),i=stringUtil.camelize(t.name);s+=`		this.fetchProperties.add("${i}", "${i}", "${a}", "${r}");\r
`});let p="";if(o.length>0){let l=o.map(e=>`${this.getJavaType(e.type)} ${stringUtil.camelize(e.name)}`).join(", "),c=o.map(e=>stringUtil.camelize(e.name)).join(", "),g='"'+o.map(e=>stringUtil.camelize(e.name)).join('", "')+'"',d=o.map(e=>stringUtil.upperCamel(stringUtil.camelize(e.name))).join("And"),m=[];o.forEach(e=>{let t=stringUtil.upperCamel(stringUtil.camelize(e.name));m.push(`input.get${t}() == null`),e.primaryKey&&e.autoIncrement&&(p=`\r
		input.set${t}(null);`)});let u=`package ${this.packageName}.service;

import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.stereotype.Service;
import lombok.RequiredArgsConstructor;

import ${this.packageName}.entity.${n};
import ${this.packageName}.entity.${n}Input;
import ${this.packageName}.output.${n}Connection;
import ${this.packageName}.repository.${n}Repository;
import ${this.packageName}.repository.${n}InputRepository;
import ${this.packageName}.utils.DataFilter;
import ${this.packageName}.utils.DataOrder;
import ${this.packageName}.utils.FetchProperties;
import ${this.packageName}.utils.PageUtil;
import ${this.packageName}.utils.SpecificationUtil;



import jakarta.annotation.PostConstruct;
import jakarta.transaction.Transactional;

/**
 * Service class for handling business logic and CRUD operations 
 * for the {@link ${n}} entity.
 *
 * <p>This service provides methods to query, create, update, and delete 
 * records from the database using the associated repository.</p>
 *
 * <p>Generated automatically by GraphQL Generator.</p>
 */
@Service
@RequiredArgsConstructor
public class ${n}Service {

    private final ${n}Repository ${i}Repository;
    private final ${n}InputRepository ${i}InputRepository;

    private FetchProperties fetchProperties;
    
    @PostConstruct
    public void init()
    {
    	fetchProperties = new FetchProperties();
    	
${s}
    }
    
    /**
     * Retrieves a paginated and optionally filtered list of {@link ${n}} records from the database.
     * This method supports dynamic filtering and sorting based on the provided criteria,
     * and wraps the result in an {@link ${n}Connection} for pagination support.
     *
     * @param pageNumber the 1-based page number for pagination (required).
     * @param pageSize the number of records to retrieve per page (required).
     * @param dataFilter an optional list of filters to be applied to the query (may be {@code null} or empty).
     * @param dataOrder an optional list of fields and their sort order to be applied to the query (may be {@code null} or empty).
     * @return {@link ${n}Connection} object containing the paginated {@link ${n}} records
     *         that match the given filtering and sorting criteria.
     */
    public ${n}Connection get${n}s(Integer pageNumber, Integer pageSize, List<DataFilter> dataFilter, List<DataOrder> dataOrder) {
    	List<DataOrder> filteredDataOrder = this.fetchProperties.filterFieldName(dataOrder);
        Page<${n}> page = ${i}Repository.findAll(
        		SpecificationUtil.createSpecificationFromFilter(dataFilter, this.fetchProperties.getFilter()), 
        		PageUtil.pageRequest(pageNumber, pageSize, filteredDataOrder, ${g})
        );
        return new ${n}Connection(page);
    }

    /**
     * Retrieves ${n} record matching the given primary key.
     *
     * @param ${o.map(e=>stringUtil.camelize(e.name)).join(", ")} the primary key value(s) used for filtering.
     * @return a list of matching ${n} entities.
     */
    public ${n} get${n}(${l}) {
        return ${i}Repository.findOneBy${d}(${c});
    }

    /**
     * Creates a new record for {@link ${n}} in the database.
     *
     * @param input the ${n} entity to be created.
     * @return the saved ${n} entity.
     */
    public ${n} create${n}(${n}Input input) {${p}
        ${n}Input saved = ${i}InputRepository.save(input);
        return ${i}Repository.findOneBy${d}(
            ${o.map(e=>`saved.get${stringUtil.upperCamel(stringUtil.camelize(e.name))}()`).join(", ")}
        );
    }

    /**
     * Updates an existing {@link ${n}} record in the database.
     *
     * @param input the ${n} entity containing updated values.
     * @return the updated ${n} entity.
     */
    public ${n} update${n}(${n}Input input) {
        if(${m.join(" || ")})
    	{
    		return null;
    	}
        ${n}Input saved = ${i}InputRepository.save(input);
        return ${i}Repository.findOneBy${d}(
            ${o.map(e=>`saved.get${stringUtil.upperCamel(stringUtil.camelize(e.name))}()`).join(", ")}
        );
    }

    /**
     * Deletes the {@link ${n}} record that matches the given primary key(s).
     *
     * @param ${o.map(e=>stringUtil.camelize(e.name)).join(", ")} the primary key value(s) of the record to delete.
     */
    @Transactional
    public void delete${n}(${l}) {
        ${i}InputRepository.deleteBy${d}(${c});
    }
}
`;a.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`service/${n}Service.java`,content:u})}}),a}gereratePageUtilFile(){let e=`package ${this.packageName}.utils;

import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;

public class PageUtil {

    /**
     * Creates a Pageable object for paginated and sorted queries.
     *
     * @param pageNumber The 1-based page number. Defaults to 1 if null or less than 1.
     * @param pageSize The number of items per page. Defaults to 20, min is 1.
     * @param orderByFields An array of field names to sort by. Defaults to ascending.
     * @return A Pageable object configured with pagination and sorting.
     */
    public static Pageable pageRequest(Integer pageNumber, Integer pageSize, String... orderByFields) {
        // Handle page number: convert to 0-based and ensure it's not negative.
        int currentPage = (pageNumber != null && pageNumber > 0) ? pageNumber - 1 : 0;
        
        // Handle page size: ensure it's at least 1.
        int rowPerPage = (pageSize != null && pageSize > 0) ? pageSize : 20;

        // Create Sort object if orderByFields are provided
        Sort sort = Sort.unsorted();
        if (orderByFields != null && orderByFields.length > 0) {
            sort = Sort.by(Direction.ASC, orderByFields);
        }
        
        return PageRequest.of(currentPage, rowPerPage, sort);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/PageUtil.java",content:e}]}generateSpecificationUtilFile(){let e=`package ${this.packageName}.utils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import org.springframework.data.jpa.domain.Specification;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class for creating dynamic JPA Specifications from DataFilters.
 * This class provides a generic method that can be used for any entity type.
 */
public class SpecificationUtil {

    private static final Logger logger = LoggerFactory.getLogger(SpecificationUtil.class);
    private static final String DATE_FORMAT = "yyyy-MM-dd";
    private static final String DATETIME_FORMAT = "yyyy-MM-dd'T'HH:mm:ss";

    /**
     * Creates a generic {@link Specification} from a list of {@link DataFilter} to build dynamic queries.
     * This method supports various filtering types based on the provided filterType map.
     *
     * @param dataFilter list of filters to apply.
     * @param filterType a map defining the data type and filter type for each field.
     * @param <T> The entity type to be filtered.
     * @return a Specification object representing the combined filters.
     */
    public static <T> Specification<T> createSpecificationFromFilter(List<DataFilter> dataFilter, Map<String, Map<String, String>> filterType) {
        if (dataFilter == null || dataFilter.isEmpty() || filterType == null) {
            return null;
        }

        Specification<T> spec = Specification.where(null);

        for (DataFilter filter : dataFilter) {
            String fieldName = filter.getFieldName();
            String fieldValue = filter.getFieldValue();

            if (fieldName != null && fieldValue != null) {
                Map<String, String> fieldInfo = filterType.get(fieldName);

                if (fieldInfo != null) {
                    String dataType = fieldInfo.get("dataType");
                    String filterOperation = fieldInfo.get("filterType");

                    if (Objects.equals(filterOperation, "exact")) {
                        switch (dataType) {
                            case "Long":
                                spec = spec.and((root, query, criteriaBuilder) ->
                                    criteriaBuilder.equal(root.get(fieldName), Long.parseLong(fieldValue))
                                );
                                break;
                            case "Integer":
                                spec = spec.and((root, query, criteriaBuilder) ->
                                    criteriaBuilder.equal(root.get(fieldName), Integer.parseInt(fieldValue))
                                );
                                break;
                            case "Double":
                            case "Float":
                                spec = spec.and((root, query, criteriaBuilder) ->
                                    criteriaBuilder.equal(root.get(fieldName), Double.parseDouble(fieldValue))
                                );
                                break;
                            case "Boolean":
                                spec = spec.and((root, query, criteriaBuilder) ->
                                    criteriaBuilder.equal(root.get(fieldName), Boolean.parseBoolean(fieldValue))
                                );
                                break;
                            case "Date":
                                spec = spec.and((root, query, criteriaBuilder) -> {
                                    try {
                                        Date date = new SimpleDateFormat(DATE_FORMAT).parse(fieldValue);
                                        return criteriaBuilder.equal(root.<Date>get(fieldName), date);
                                    } catch (ParseException e) {
                                        logger.error("Error parsing date for field {}: {}", fieldName, e.getMessage());
                                        return criteriaBuilder.disjunction(); // Return a false predicate
                                    }
                                });
                                break;
                            case "DateTime":
                                spec = spec.and((root, query, criteriaBuilder) -> {
                                    try {
                                        Date dateTime = new SimpleDateFormat(DATETIME_FORMAT).parse(fieldValue);
                                        return criteriaBuilder.equal(root.<Date>get(fieldName), dateTime);
                                    } catch (ParseException e) {
                                        logger.error("Error parsing datetime for field {}: {}", fieldName, e.getMessage());
                                        return criteriaBuilder.disjunction(); // Return a false predicate
                                    }
                                });
                                break;
                            case "String":
                                spec = spec.and((root, query, criteriaBuilder) ->
                                    criteriaBuilder.equal(root.get(fieldName), fieldValue)
                                );
                                break;
                            default:
                                // Handle unsupported data types, e.g., log a warning
                                break;
                        }
                    } else if (Objects.equals(filterOperation, "partial")) {
                        if (Objects.equals(dataType, "String")) {
                            spec = spec.and((root, query, criteriaBuilder) ->
                                criteriaBuilder.like(criteriaBuilder.lower(root.get(fieldName)), "%" + fieldValue.toLowerCase() + "%")
                            );
                        }
                    }
                }
            }
        }
        return spec;
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/SpecificationUtil.java",content:e}]}generateDataFilterFile(){let e=`package ${this.packageName}.utils;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class DataFilter {
	String fieldName;
	String fieldValue;
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/DataFilter.java",content:e}]}generateDataOrderFile(){let e=`package ${this.packageName}.utils;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class DataOrder {
	String fieldName;
	String orderType;
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/DataOrder.java",content:e}]}getNestedRelations(e,t,a="",r=2){if(r<=0)return[];let i=[],n=this.getPrimaryKeys(t).length>1;return t.columns.forEach(o=>{if(this.isForeignKey(e,t,o)&&!n){let s=stringUtil.camelize(o.name.replace(/_id$/i,"")),p=a?`${a}.${s}`:s;i.push(p);let l=e.find(e=>e.name.toLowerCase()===s.toLowerCase());l&&i.push(...this.getNestedRelations(e,l,p,r-1))}}),t.columns.forEach(t=>{if(n){let o=stringUtil.camelize(t.name.replace(/_id$/i,"")),s=a?`${a}.${o}`:o;i.push(s);let p=e.find(e=>e.name.toLowerCase()===o.toLowerCase());p&&i.push(...this.getNestedRelations(e,p,s,r-1))}}),i}generateConnectionFiles(){let e=this.model.entities,t=[];return e.forEach(e=>{let a=stringUtil.camelize(e.name),r=stringUtil.upperCamel(a),i=`package ${this.packageName}.output;

import org.springframework.data.domain.Page;

import ${this.packageName}.entity.${r};
import ${this.packageName}.utils.PageInfo;

/**
 * A connection wrapper for paginated {@link ${r}} results.
 * <p>
 * This class encapsulates both the paginated list of {@link ${r}} entities
 * and pagination metadata via {@link PageInfo}.
 * It is commonly used as a GraphQL-compatible representation of
 * paginated query results.
 * </p>
 */
public class ${r}Connection
{
    /**
     * Pagination metadata, including total records, total pages,
     * current page number, and page size.
     */
    private PageInfo pageInfo;

    /**
     * The underlying paginated data of {@link ${r}} entities.
     */
    private Page<${r}> data;

    /**
     * Constructs a new {@code ${r}Connection} from a Spring Data {@link Page}.
     * <p>
     * The {@link PageInfo} is initialized from the provided {@link Page}
     * to represent pagination details.
     * </p>
     *
     * @param page the {@link Page} of {@link ${r}} entities to wrap.
     */
    public ${r}Connection(Page<${r}> page)
    {
        this.data = page;
        this.pageInfo = new PageInfo(page);
    }
}

`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`output/${r}Connection.java`,content:i})}),t}generateRepositoryFiles(){let e=this.model.entities,t=[],a=this;return e.forEach(r=>{let i=stringUtil.camelize(r.name),n=stringUtil.upperCamel(i),o=this.getPrimaryKeys(r);if(o.length>0){let s=o.length>1?`${n}Id`:this.getJavaType(o[0].type),p=o.map(e=>stringUtil.upperCamel(stringUtil.camelize(e.name))).join("And"),l=o.map(e=>`${this.getJavaType(e.type)} ${stringUtil.camelize(e.name)}`).join(", "),c="";["String","Long","Integer","Double","Float","Boolean","Character","Byte","Short"].includes(s)||s.includes(".")||(c=`import ${this.packageName}.entity.${s};
`);let g=this.getNestedRelations(e,r,"",a.maxRelationDepth||3),d="";(g.length>0||o.length>1)&&(d=`    @EntityGraph(attributePaths = { ${g.map(e=>`"${e}"`).join(", ")} })
`);let m=`package ${this.packageName}.repository;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
${g.length>0?"import org.springframework.data.jpa.repository.EntityGraph;\n":""}
import ${this.packageName}.entity.${n};
${c}
/**
 * Repository interface for {@link ${n}} entity.
 * <p>Provides basic CRUD operations and custom queries.</p>
 */
@Repository
public interface ${n}Repository extends JpaRepository<${n}, ${s}> {

${d}    ${n} findOneBy${p}(${l});

${d}    Page<${n}> findAll(Specification<${n}> specification, Pageable pageable);
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`repository/${n}Repository.java`,content:m});let u=`package ${this.packageName}.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ${this.packageName}.entity.${n}Input;
${c}
/**
 * Repository interface for {@link ${n}Input} entity.
 * <p>Provides basic CRUD operations and custom queries for input version.</p>
 */
@Repository
public interface ${n}InputRepository extends JpaRepository<${n}Input, ${s}> {

    ${n}Input findOneBy${p}(${l});

    void deleteBy${p}(${l});
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`repository/${n}InputRepository.java`,content:u})}}),t}generateEntityFiles(){let e=this,t=this.model.entities,a=[];return t.forEach(t=>{let r=t.name,i=stringUtil.upperCamel(stringUtil.camelize(r)),n=stringUtil.snakeize(r),o=this.getPrimaryKeys(t),s=`package ${this.packageName}.entity;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PostLoad;
import jakarta.persistence.Table;

import lombok.Setter;
import lombok.Getter;

/**
 * Entity class representing the ${i} table in the database.
 * 
 * <p>This class is automatically generated by GraphQL Generator.</p>
 * <p>Contains fields for each column in the table, with appropriate annotations for JPA.</p>
 */
@Entity
@Table(name = "${n}")
@Setter
@Getter
`;o.length>1&&(s+=`@IdClass(${i}Id.class)
`),s+=`public class ${i} {

`;let p=[];t.columns.forEach(a=>{let r=a.name,i=stringUtil.camelize(r),n=a.type,l=this.getJavaType(n),c=i.substring(0,i.length-2),g=stringUtil.upperCamel(c);if(a.primaryKey&&(s+=`    @Id
`,a.autoIncrement&&(s+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),e.isForeignKey(e.model.entities,t,a)){s+=`    @Column(name = "${r}")
    private ${l} ${i};

`;s+=`    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "${a.name}", referencedColumnName = "${a.name}", insertable=false, updatable=false)
    private ${g} ${c};

`,p.push({name:c,type:g})}else s+=`    @Column(name = "${r}")
    private ${l} ${i};

`;o.length>1&&a.primaryKey&&!a.autoIncrement&&(s+=`    @ManyToOne
    @JoinColumn(name = "${r}", referencedColumnName = "${r}", insertable = false, updatable = false)
    private ${g} ${c};

`)}),p.length>0&&(s+=`
    @PostLoad
    public void initRelationsIfNull() {
`,p.forEach(e=>{s+=`        if (this.${e.name} == null) {
            this.${e.name} = new ${e.type}();
        }
`}),s+=`    }
`),s+=`}
`,a.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${i}.java`,content:s});let l=`package ${this.packageName}.entity;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.Table;

import lombok.Setter;
import lombok.Getter;

/**
 * Entity class representing the ${i} table in the database.
 * 
 * <p>This class is automatically generated by GraphQL Generator.</p>
 * <p>Contains fields for each column in the table, with appropriate annotations for JPA.</p>
 */
@Entity
@Table(name = "${n}")
@Setter
@Getter
`;o.length>1&&(l+=`@IdClass(${i}Id.class)
`),l+=`public class ${i}Input {

`,t.columns.forEach(e=>{let t=e.name,a=stringUtil.camelize(t),r=e.type,i=this.getJavaType(r);e.primaryKey&&(l+=`    @Id
`,e.autoIncrement&&(l+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),l+=`    @Column(name = "${t}")
    private ${i} ${a};

`}),l+=`}
`,a.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${i}Input.java`,content:l})}),a}generateFetchPropertiesFile(){let e=`package ${this.packageName}.utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import lombok.Getter;
import lombok.Setter;

/**
 * A utility class to manage and filter properties for data fetching operations.
 * It stores configurations for filtering and ordering fields, and provides
 * methods to ensure that requested fields are valid and supported.
 */
@Getter
@Setter
public class FetchProperties {
	
	private Map<String, Map<String, String>> filter;
	private List<Map<String, String>> order;
	
	public FetchProperties()
	{
		this.filter = new HashMap<>();
		this.order = new ArrayList<>();
	}

	/**
	 * Adds a field to the filter configuration.
	 *
	 * @param key The unique key for the filter (e.g., a field name).
	 * @param fieldName The actual name of the field in the entity.
	 * @param dataType The data type of the field (e.g., "String", "Long").
	 * @param filterType The type of filter operation (e.g., "exact", "partial").
	 */
	public void add(String key, String fieldName, String dataType, String filterType) {
		this.filter.put(key, this.createFilterType(fieldName, dataType, filterType));
	}

	/**
	 * Creates a map representing a single filter type configuration.
	 *
	 * @param fieldName The name of the field.
	 * @param dataType The data type of the field.
	 * @param filterType The filter operation type.
	 * @return A map containing the filter properties.
	 */
	private Map<String, String> createFilterType(String fieldName, String dataType, String filterType) {
		Map<String, String> field = new HashMap<>();
		
		field.put("fieldName", fieldName);
		field.put("dataType", dataType);
		field.put("filterType", filterType);
		
		return field;
	}

	/**
	 * Filters a list of data orders to include only those fields that are
	 * configured for filtering in this utility.
	 *
	 * @param dataOrder The list of data orders to filter.
	 * @return A new list containing only the valid data orders.
	 */
	public List<DataOrder> filterFieldName(List<DataOrder> dataOrder) {
		if(dataOrder == null)
		{
			return dataOrder;
		}
		List<DataOrder> result = new ArrayList<>();
		for(DataOrder item : dataOrder)
		{
			if(this.inList(item))
			{
				result.add(item);
			}
		}
		
		return result;
	}
	
	/**
	 * Checks if a given data order field is present in the configured filter list.
	 *
	 * @param order The DataOrder object to check.
	 * @return {@code true} if the field is in the filter list, {@code false} otherwise.
	 */
	public boolean inList(DataOrder order)
	{
		for(Entry<String, Map<String, String>> entry : this.filter.entrySet())
		{
			if(entry.getValue().getOrDefault("fieldName", "").equals(order.getFieldName()))
			{
				return true;
			}
		}
		return false;
	}
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/FetchProperties.java",content:e}]}generatePageUtilFile(){let e=`package ${this.packageName}.utils;

import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import java.util.List;
import java.util.ArrayList;
import java.util.Objects;

public class PageUtil {

    /**
     * Creates a Pageable object for paginated and sorted queries.
     *
     * @param pageNumber The 1-based page number. Defaults to 1 if null or less than 1.
     * @param pageSize The number of items per page. Defaults to 20, min is 1.
     * @param sortFields A list of maps, with each map containing "fieldName" and "sortType".
     * @param orderByFields An array of field names to sort by. Defaults to ascending.
     * @return A Pageable object configured with pagination and sorting.
     */
    public static Pageable pageRequest(Integer pageNumber, Integer pageSize, List<DataOrder> sortFields, String... orderByFields) {
        // Handle page number: convert to 0-based and ensure it's not negative.
        int currentPage = (pageNumber != null && pageNumber > 0) ? pageNumber - 1 : 0;
        
        // Handle page size: ensure it's at least 1.
        int rowPerPage = (pageSize != null && pageSize > 0) ? pageSize : 20;
        
        Sort sort = createSortFromList(sortFields);

        if (sort.isUnsorted() && orderByFields != null && orderByFields.length > 0) {
            sort = Sort.by(Direction.ASC, orderByFields);
        }
        
        return PageRequest.of(currentPage, rowPerPage, sort);
    }
    
    /**
     * Creates a {@link Sort} object from a list of maps, where each map
     * specifies a field to sort by and the sort direction.
     *
     * @param sortFields A list of maps, with each map containing "fieldName" and "sortType" (e.g., "asc" or "desc").
     * @return a Sort object representing the combined sorting criteria.
     */
    public static Sort createSortFromList(List<DataOrder> sortFields) {
        if (sortFields == null || sortFields.isEmpty()) {
            // Return unsorted object if no fields are provided
            return Sort.unsorted();
        }

        List<Order> orders = new ArrayList<>();
        for (DataOrder field : sortFields) {
            String fieldName = field.getFieldName();
            String orderTypeType = field.getOrderType();
            if(orderTypeType == null)
            {
            	orderTypeType = "asc";
            }

            if (fieldName != null && orderTypeType != null) {
                // Default direction is ASC
                Direction direction = Direction.ASC;
                if (Objects.equals(orderTypeType.toLowerCase(), "desc")) {
                    direction = Direction.DESC;
                }
                orders.add(new Order(direction, fieldName));
            }
        }
        
        // If the list of orders is empty after processing, return unsorted
        if (orders.isEmpty()) {
            return Sort.unsorted();
        }

        return Sort.by(orders);
    }


}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/PageUtil.java",content:e}]}isForeignKey(e,t,a){if(a.primaryKey)return!1;for(let r of e){if(r.name===t.name)continue;let i=this.getPrimaryKeys(r);for(let n of i)if(n.name===a.name)return!0}return!1}generateIdClassFiles(){let e=[];return this.model.entities.forEach(t=>{let a=this.getPrimaryKeys(t);if(a.length>1){let r=`${stringUtil.upperCamel(stringUtil.camelize(t.name))}Id`,i=`package ${this.packageName}.entity;

import java.io.Serializable;
import java.util.Objects;
import jakarta.persistence.Embeddable;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;

import lombok.Setter;
import lombok.Getter;

@Embeddable
@Setter
@Getter
public class ${r} implements Serializable {

`;a.forEach(e=>{let t=stringUtil.camelize(e.name),a=this.getJavaType(e.type);e.primaryKey&&(i+="",e.autoIncrement&&(i+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),i+=`    private ${a} ${t};

`}),i+=`    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ${r} that = (${r}) o;
        return ${a.map(e=>`Objects.equals(${stringUtil.camelize(e.name)}, that.${stringUtil.camelize(e.name)})`).join(" && ")};
    }

    @Override
    public int hashCode() {
        return Objects.hash(${a.map(e=>stringUtil.camelize(e.name)).join(", ")});
    }

`,i+=`}
`,e.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${r}.java`,content:i})}}),e}generateGraphQlSchema(){return[{name:"src/main/resources/graphql/schema.graphqls",content:util.buildGraphQLSchema(this.model.entities,!1)}]}generatePageInfoFile(){let e=`package ${this.packageName}.utils;

import lombok.Getter;
import lombok.Setter;

import org.springframework.data.domain.Page;

@Setter
@Getter
public class PageInfo {
	Integer totalCount;
    Integer totalPages;
    Integer currentPage;
    Integer pageSize;
    Boolean hasNextPage; 
    Boolean hasPreviousPage;

	public PageInfo(Page<?> page)
	{
		this.totalCount = page.getNumberOfElements();
		this.totalPages = page.getTotalPages();
		this.currentPage = page.getNumber() + 1;
		this.pageSize = page.getSize();
		this.hasNextPage = page.hasNext();
		this.hasPreviousPage = page.hasPrevious();
	}
}



`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/PageInfo.java",content:e}]}generatePomFile(){let e={groupId:this.groupId,artifactId:this.artifactId,version:this.version,name:this.serviceName,description:this.serviceDescription,javaVersion:this.javaVersion,packageName:this.packageName},t=`<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.5.4</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>
<groupId>${e.groupId}</groupId>
<artifactId>${e.artifactId}</artifactId>
<version>${e.version}</version>
<name>${e.name}</name>
<description>${e.description}</description>
<url/>
<licenses>
    <license/>
</licenses>
<developers>
    <developer/>
</developers>
<scm>
    <connection/>
    <developerConnection/>
    <tag/>
    <url/>
</scm>
<properties>
    <java.version>${e.javaVersion}</java.version>
</properties>
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-graphql</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <configuration>
                <annotationProcessorPaths>
                    <path>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                    </path>
                </annotationProcessorPaths>
            </configuration>
        </plugin>
        <plugin>
            <groupId>io.github.deweyjose</groupId>
            <artifactId>graphqlcodegen-maven-plugin</artifactId>
            <version>1.61.5</version>
            <executions>
                <execution>
                    <id>dgs-codegen</id>
                    <goals>
                        <goal>generate</goal>
                    </goals>
                    <configuration>
                        <schemaPaths>
                            <param>src/main/resources/graphql</param>
                        </schemaPaths>
                        <packageName>${e.packageName}.codegen</packageName>
                        <addGeneratedAnnotation>true</addGeneratedAnnotation>
                        <disableDatesInGeneratedAnnotation>true</disableDatesInGeneratedAnnotation>
                    </configuration>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>build-helper-maven-plugin</artifactId>
            <executions>
                <execution>
                    <id>add-dgs-source</id>
                    <phase>generate-sources</phase>
                    <goals>
                        <goal>add-source</goal>
                    </goals>
                    <configuration>
                        <sources>
                            <source>\${project.build.directory}/generated-sources</source>
                        </sources>
                    </configuration>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludes>
                    <exclude>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                    </exclude>
                </excludes>
            </configuration>
        </plugin>
    </plugins>
</build>

</project>
`;return[{name:"pom.xml",content:t}]}getDataType(e){if(null==e)return"String";switch(e.toUpperCase()){case"CHAR":case"VARCHAR":case"TEXT":case"LONGTEXT":case"MEDIUMTEXT":default:return"String";case"TINYINT":case"SMALLINT":case"MEDIUMINT":case"INT":return"Integer";case"BIGINT":return"Long";case"FLOAT":return"Float";case"DOUBLE":case"DECIMAL":return"Double";case"BOOLEAN":return"Boolean";case"DATE":return"Date";case"DATETIME":case"TIMESTAMP":return"DateTime"}}getFilterType(e){return null==e||"String"===e?"partial":"exact"}}