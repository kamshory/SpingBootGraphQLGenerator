class GraphQLSpringGenerator{constructor(){this.packageName=null,this.groupId=null,this.artifactId=null,this.serviceName=null,this.serviceDescription=null,this.javaVersion=null,this.version=null,this.maxRelationDepth=3,this.model=null}generateVirtualFiles(){let e={port:parseInt(document.querySelector("#appPort").value.trim(),10)},t={url:document.querySelector("#dbUrl").value.trim(),username:document.querySelector("#dbUsername").value.trim(),password:document.querySelector("#dbPassword").value,driver:document.querySelector("#dbDriver").value.trim(),showSql:"true"===document.querySelector("#dbShowSql").value,dialect:document.querySelector("#dbDialect").value.trim()},r=[];return r.push(...this.generateIdClassFiles()),r.push(...this.generateEntityFiles()),r.push(...this.generateRepositoryFiles()),r.push(...this.generateServiceFiles()),r.push(...this.generateControllerFiles()),r.push(...this.generateGraphQlSchema()),r.push(...this.generatePomFile()),r.push(...this.generateApplicationFile()),r.push(...this.generateDataFilterFile()),r.push(...this.generateDataOrderFile()),r.push(...this.generateFetchPropertiesFile()),r.push(...this.generateSpecificationUtilFile()),r.push(...this.generatePageUtilFile()),r.push(...this.generateApplicationPropertiesFile(e,t)),r.push(...Maven.generateMavenFile()),r.push(...Maven.generateMavenCmdFile()),r.push(...Maven.generateMavenWrapperFiles()),r}async createZipFile(e,t={},r="servicegen.zip"){this.packageName=t.packageName||"com.example.servicegen",this.groupId=t.groupId||"com.example",this.artifactId=t.artifactId||"servicegen",this.serviceName=t.serviceName||"Service Generator",this.serviceDescription=t.serviceDescription||"A service generator for Spring GraphQL",this.javaVersion=t.javaVersion||"21",this.version=t.version||"1.0.0",this.maxRelationDepth=3,this.model=e;let a=document.getElementById("loading");a.style.display="block";let i=this.generateVirtualFiles();if(0===i.length){alert("Tidak ada file untuk dikompresi."),a.style.display="none";return}let o=new JSZip;for(let n of i)o.file(n.name,n.content);try{let s=await o.generateAsync({type:"blob"});saveAs(s,r)}catch(p){console.error("Gagal membuat file ZIP:",p)}finally{a.style.display="none"}}camelize(e){let t=e.replace(/[^a-zA-Z0-9 ]/g," ").toLowerCase();return t.split(" ").map((e,t)=>0===t?e:e.charAt(0).toUpperCase()+e.slice(1)).join("")}upperCamel(e){return e.replace(/([A-Z])/g,"$1").replace(/^./,e=>e.toUpperCase())}snakeize(e){return e.replace(/[_\-]+/g," ").replace(/([a-z])([A-Z])/g,"$1 $2").replace(/[^a-zA-Z0-9 ]+/g,"").toLowerCase().replace(/\b\w/g,e=>e.toUpperCase()).replace(/\s+/g,"_").toLowerCase().replace(/^_+|_+$/g,"").replace(/__+/g,"_")}getPrimaryKeys(e){return e.columns.filter(e=>e.primaryKey)}getPrimatyKey(e){let t=e.columns.find(e=>e.primaryKey);return t?{primaryKeyName:t.name,primaryKeyCamel:this.camelize(t.name),primaryKeyType:t.type,primaryKeyJavaType:this.getJavaType(t.type)}:null}getJavaType(e){let t=e.toLowerCase();if(-1!==t.indexOf("int")||-1!==t.indexOf("integer")||-1!==t.indexOf("tinyint")||-1!==t.indexOf("long")||-1!==t.indexOf("bigint"))return"Long";if(-1!==t.indexOf("string")||-1!==t.indexOf("varchar")||-1!==t.indexOf("text"))return"String";if(-1!==t.indexOf("boolean"))return"Boolean";if(-1!==t.indexOf("date")||-1!==t.indexOf("timestamp"))return"Date";else if(-1!==t.indexOf("double")||-1!==t.indexOf("float"))return"Double";else if(-1!==t.indexOf("uuid"))return"UUID";else if(-1!==t.indexOf("bigdecimal"))return"BigDecimal";else if(-1!==t.indexOf("number")||-1!==t.indexOf("real")||-1!==t.indexOf("decimal")||-1!==t.indexOf("numeric"))return"Double";return"Object"}createSourceDirectoryFromArtefact(e){return"src/main/java/"+e.split(".").join("/")+"/"}generateApplicationFile(){let e=`package ${this.packageName};

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"Application.java",content:e}]}generateApplicationPropertiesFile(e,t){let r=`# Spring Boot application properties
# Server port
server.port=${e.port||8080}
# Database configuration
spring.datasource.url=${t.url||"jdbc:mysql://localhost:3306/mydb"}
spring.datasource.username=${t.username||"root"}
spring.datasource.password=${t.password||""}
spring.datasource.driver-class-name=${t.driver||"com.mysql.cj.jdbc.Driver"}
# JPA/Hibernate configuration
spring.jpa.show-sql=${t.showSql||"true"}
spring.jpa.properties.hibernate.dialect=${t.dialect}
# GraphQL configuration
spring.graphql.schema-location=classpath:graphql/schema.graphqls
# Logging configuration
logging.level.org.springframework=INFO
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
# Application name and description
spring.application.name=${this.serviceName}
spring.application.description=${this.serviceDescription}
# Java version
spring.java.version=${this.javaVersion}
# Package name
spring.package.name=${this.packageName}
# Version
spring.application.version=${this.version}
`;return[{name:"src/main/resources/application.properties",content:r}]}generateControllerFiles(){let e=this.model.entities,t=[];return e.forEach(e=>{let r=e.name,a=this.camelize(r),i=this.upperCamel(a),o=this.getPrimaryKeys(e);if(o.length>0){let n=o.map(e=>`@Argument ${this.getJavaType(e.type)} ${this.camelize(e.name)}`).join(", "),s=o.map(e=>this.camelize(e.name)).join(", ");o.map(e=>this.upperCamel(this.camelize(e.name))).join("And");let p=`package ${this.packageName}.controller;

import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.stereotype.Controller;
import ${this.packageName}.utils.DataFilter;
import ${this.packageName}.utils.DataOrder;
import ${this.packageName}.entity.${i};
import ${this.packageName}.entity.${i}Input;
import ${this.packageName}.service.${i}Service;

import lombok.RequiredArgsConstructor;

@Controller
@RequiredArgsConstructor
public class ${i}Controller {

    private final ${i}Service ${a}Service;

    @QueryMapping
    public Page<${i}> get${i}s(@Argument(name = "pageNumber") Integer pageNumber, @Argument(name = "pageSize") Integer pageSize, @Argument(name = "dataFilter") List<DataFilter> dataFilter, @Argument(name = "dataOrder") List<DataOrder> dataOrder) {
        return ${a}Service.get${i}s(pageNumber, pageSize, dataFilter, dataOrder);
    }

    @QueryMapping
    public ${i} get${i}(${n}) {
        return ${a}Service.get${i}(${s});
    }

    @MutationMapping
    public ${i} create${i}(@Argument ${i}Input input) {
        return ${a}Service.create${i}(input);
    }

    @MutationMapping
    public ${i} update${i}(@Argument ${i}Input input) {
        return ${a}Service.update${i}(input);
    }

    @MutationMapping
    public Boolean delete${i}(${n}) {
        ${a}Service.delete${i}(${s});
        return true;
    }
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`controller/${i}Controller.java`,content:p})}}),t}generateServiceFiles(){let e=this,t=this.model.entities,r=[];return t.forEach(t=>{let a=t.name,i=this.camelize(a),o=this.upperCamel(i),n=this.getPrimaryKeys(t),s="";if(t.columns.forEach(t=>{let r=e.getDataType(t.type),a=e.getFilterType(r),i=e.camelize(t.name);s+=`		this.fetchProperties.add("${i}", "${i}", "${r}", "${a}");\r
`}),n.length>0){let p=n.map(e=>`${this.getJavaType(e.type)} ${this.camelize(e.name)}`).join(", "),l=n.map(e=>this.camelize(e.name)).join(", "),c='"'+n.map(e=>this.camelize(e.name)).join('", "')+'"',d=n.map(e=>this.upperCamel(this.camelize(e.name))).join("And"),m=[];n.forEach(t=>{let r=e.upperCamel(e.camelize(t.name));m.push(`input.get${r}() == null`)});let u=`package ${this.packageName}.service;

import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.stereotype.Service;
import lombok.RequiredArgsConstructor;

import ${this.packageName}.entity.${o};
import ${this.packageName}.entity.${o}Input;
import ${this.packageName}.repository.${o}Repository;
import ${this.packageName}.repository.${o}InputRepository;
import ${this.packageName}.utils.DataFilter;
import ${this.packageName}.utils.DataOrder;
import ${this.packageName}.utils.FetchProperties;
import ${this.packageName}.utils.PageUtil;
import ${this.packageName}.utils.SpecificationUtil;

import jakarta.annotation.PostConstruct;
import jakarta.transaction.Transactional;

/**
 * Service class for handling business logic and CRUD operations 
 * for the {@link ${o}} entity.
 *
 * <p>This service provides methods to query, create, update, and delete 
 * records from the database using the associated repository.</p>
 *
 * <p>Generated automatically by GraphQL Generator.</p>
 */
@Service
@RequiredArgsConstructor
public class ${o}Service {

    private final ${o}Repository ${i}Repository;
    private final ${o}InputRepository ${i}InputRepository;

    private FetchProperties fetchProperties;
    
    @PostConstruct
    public void init()
    {
    	fetchProperties = new FetchProperties();
    	
${s}
    }
    
    /**
     * Retrieves a paginated and filtered list of all {@link ${o}} records from the database.
     * This method supports dynamic filtering and ordering based on provided criteria.
     *
     * @param pageNumber The 1-based page number for pagination.
     * @param pageSize The number of records to retrieve per page.
     * @param dataFilter A list of filters to be applied to the query.
     * @param dataOrder A list of fields and their sort order to be applied to the query.
     * @return A {@link Page} object containing the ${o} entities that match the criteria.
     */
    public Page<${o}> get${o}s(Integer pageNumber, Integer pageSize, List<DataFilter> dataFilter, List<DataOrder> dataOrder) {
    	List<DataOrder> filteredDataOrder = this.fetchProperties.filterFieldName(dataOrder);
        return ${i}Repository.findAll(
        		SpecificationUtil.createSpecificationFromFilter(dataFilter, this.fetchProperties.getFilter()), 
        		PageUtil.pageRequest(pageNumber, pageSize, filteredDataOrder, ${c})
        );
    }

    /**
     * Retrieves ${o} record matching the given primary key.
     *
     * @param ${n.map(e=>this.camelize(e.name)).join(", ")} the primary key value(s) used for filtering.
     * @return a list of matching ${o} entities.
     */
    public ${o} get${o}(${p}) {
        return ${i}Repository.findOneBy${d}(${l});
    }

    /**
     * Creates a new record for {@link ${o}} in the database.
     *
     * @param input the ${o} entity to be created.
     * @return the saved ${o} entity.
     */
    public ${o} create${o}(${o}Input input) {
        ${o}Input saved = ${i}InputRepository.save(input);
        return ${i}Repository.findOneBy${d}(
            ${n.map(e=>`saved.get${this.upperCamel(this.camelize(e.name))}()`).join(", ")}
        );
    }

    /**
     * Updates an existing {@link ${o}} record in the database.
     *
     * @param input the ${o} entity containing updated values.
     * @return the updated ${o} entity.
     */
    public ${o} update${o}(${o}Input input) {
        if(${m.join(" || ")})
    	{
    		return null;
    	}
        ${o}Input saved = ${i}InputRepository.save(input);
        return ${i}Repository.findOneBy${d}(
            ${n.map(e=>`saved.get${this.upperCamel(this.camelize(e.name))}()`).join(", ")}
        );
    }

    /**
     * Deletes the {@link ${o}} record that matches the given primary key(s).
     *
     * @param ${n.map(e=>this.camelize(e.name)).join(", ")} the primary key value(s) of the record to delete.
     */
    @Transactional
    public void delete${o}(${p}) {
        ${i}InputRepository.deleteBy${d}(${l});
    }
}
`;r.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`service/${o}Service.java`,content:u})}}),r}gereratePageUtilFile(){let e=`package ${this.packageName}.utils;

import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;

public class PageUtil {

    /**
     * Creates a Pageable object for paginated and sorted queries.
     *
     * @param pageNumber The 1-based page number. Defaults to 1 if null or less than 1.
     * @param pageSize The number of items per page. Defaults to 20, min is 1.
     * @param orderByFields An array of field names to sort by. Defaults to ascending.
     * @return A Pageable object configured with pagination and sorting.
     */
    public static Pageable pageRequest(Integer pageNumber, Integer pageSize, String... orderByFields) {
        // Handle page number: convert to 0-based and ensure it's not negative.
        int currentPage = (pageNumber != null && pageNumber > 0) ? pageNumber - 1 : 0;
        
        // Handle page size: ensure it's at least 1.
        int rowPerPage = (pageSize != null && pageSize > 0) ? pageSize : 20;

        // Create Sort object if orderByFields are provided
        Sort sort = Sort.unsorted();
        if (orderByFields != null && orderByFields.length > 0) {
            sort = Sort.by(Direction.ASC, orderByFields);
        }
        
        return PageRequest.of(currentPage, rowPerPage, sort);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/PageUtil.java",content:e}]}generateSpecificationUtilFile(){let e=`package ${this.packageName}.utils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import org.springframework.data.jpa.domain.Specification;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class for creating dynamic JPA Specifications from DataFilters.
 * This class provides a generic method that can be used for any entity type.
 */
public class SpecificationUtil {

    private static final Logger logger = LoggerFactory.getLogger(SpecificationUtil.class);
    private static final String DATE_FORMAT = "yyyy-MM-dd";
    private static final String DATETIME_FORMAT = "yyyy-MM-dd'T'HH:mm:ss";

    /**
     * Creates a generic {@link Specification} from a list of {@link DataFilter} to build dynamic queries.
     * This method supports various filtering types based on the provided filterType map.
     *
     * @param dataFilter list of filters to apply.
     * @param filterType a map defining the data type and filter type for each field.
     * @param <T> The entity type to be filtered.
     * @return a Specification object representing the combined filters.
     */
    public static <T> Specification<T> createSpecificationFromFilter(List<DataFilter> dataFilter, Map<String, Map<String, String>> filterType) {
        if (dataFilter == null || dataFilter.isEmpty() || filterType == null) {
            return null;
        }

        Specification<T> spec = Specification.where(null);

        for (DataFilter filter : dataFilter) {
            String fieldName = filter.getFieldName();
            String fieldValue = filter.getFieldValue();

            if (fieldName != null && fieldValue != null) {
                Map<String, String> fieldInfo = filterType.get(fieldName);

                if (fieldInfo != null) {
                    String dataType = fieldInfo.get("dataType");
                    String filterOperation = fieldInfo.get("filterType");

                    if (Objects.equals(filterOperation, "exact")) {
                        switch (dataType) {
                            case "Long":
                                spec = spec.and((root, query, criteriaBuilder) ->
                                    criteriaBuilder.equal(root.get(fieldName), Long.parseLong(fieldValue))
                                );
                                break;
                            case "Integer":
                                spec = spec.and((root, query, criteriaBuilder) ->
                                    criteriaBuilder.equal(root.get(fieldName), Integer.parseInt(fieldValue))
                                );
                                break;
                            case "Double":
                            case "Float":
                                spec = spec.and((root, query, criteriaBuilder) ->
                                    criteriaBuilder.equal(root.get(fieldName), Double.parseDouble(fieldValue))
                                );
                                break;
                            case "Boolean":
                                spec = spec.and((root, query, criteriaBuilder) ->
                                    criteriaBuilder.equal(root.get(fieldName), Boolean.parseBoolean(fieldValue))
                                );
                                break;
                            case "Date":
                                spec = spec.and((root, query, criteriaBuilder) -> {
                                    try {
                                        Date date = new SimpleDateFormat(DATE_FORMAT).parse(fieldValue);
                                        return criteriaBuilder.equal(root.<Date>get(fieldName), date);
                                    } catch (ParseException e) {
                                        logger.error("Error parsing date for field {}: {}", fieldName, e.getMessage());
                                        return criteriaBuilder.disjunction(); // Return a false predicate
                                    }
                                });
                                break;
                            case "DateTime":
                                spec = spec.and((root, query, criteriaBuilder) -> {
                                    try {
                                        Date dateTime = new SimpleDateFormat(DATETIME_FORMAT).parse(fieldValue);
                                        return criteriaBuilder.equal(root.<Date>get(fieldName), dateTime);
                                    } catch (ParseException e) {
                                        logger.error("Error parsing datetime for field {}: {}", fieldName, e.getMessage());
                                        return criteriaBuilder.disjunction(); // Return a false predicate
                                    }
                                });
                                break;
                            case "String":
                                spec = spec.and((root, query, criteriaBuilder) ->
                                    criteriaBuilder.equal(root.get(fieldName), fieldValue)
                                );
                                break;
                            default:
                                // Handle unsupported data types, e.g., log a warning
                                break;
                        }
                    } else if (Objects.equals(filterOperation, "partial")) {
                        if (Objects.equals(dataType, "String")) {
                            spec = spec.and((root, query, criteriaBuilder) ->
                                criteriaBuilder.like(criteriaBuilder.lower(root.get(fieldName)), "%" + fieldValue.toLowerCase() + "%")
                            );
                        }
                    }
                }
            }
        }
        return spec;
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/SpecificationUtil.java",content:e}]}generateDataFilterFile(){let e=`package ${this.packageName}.utils;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class DataFilter {
	String fieldName;
	String fieldValue;
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/DataFilter.java",content:e}]}generateDataOrderFile(){let e=`package ${this.packageName}.utils;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class DataOrder {
	String fieldName;
	String orderType;
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/DataOrder.java",content:e}]}getNestedRelations(e,t,r="",a=2){if(a<=0)return[];let i=[],o=this.getPrimaryKeys(t).length>1;return t.columns.forEach(n=>{if(this.isForeignKey(e,t,n)&&!o){let s=this.camelize(n.name.replace(/_id$/i,"")),p=r?`${r}.${s}`:s;i.push(p);let l=e.find(e=>e.name.toLowerCase()===s.toLowerCase());l&&i.push(...this.getNestedRelations(e,l,p,a-1))}}),t.columns.forEach(t=>{if(o){let n=this.camelize(t.name.replace(/_id$/i,"")),s=r?`${r}.${n}`:n;i.push(s);let p=e.find(e=>e.name.toLowerCase()===n.toLowerCase());p&&i.push(...this.getNestedRelations(e,p,s,a-1))}}),i}generateRepositoryFiles(){let e=this.model.entities,t=[],r=this;return e.forEach(a=>{let i=this.camelize(a.name),o=this.upperCamel(i),n=this.getPrimaryKeys(a);if(n.length>0){let s=n.length>1?`${o}Id`:this.getJavaType(n[0].type),p=n.map(e=>this.upperCamel(this.camelize(e.name))).join("And"),l=n.map(e=>`${this.getJavaType(e.type)} ${this.camelize(e.name)}`).join(", "),c="";["String","Long","Integer","Double","Float","Boolean","Character","Byte","Short"].includes(s)||s.includes(".")||(c=`import ${this.packageName}.entity.${s};
`);let d=this.getNestedRelations(e,a,"",r.maxRelationDepth||3),m="";(d.length>0||n.length>1)&&(m=`    @EntityGraph(attributePaths = { ${d.map(e=>`"${e}"`).join(", ")} })
`);let u=`package ${this.packageName}.repository;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
${d.length>0?"import org.springframework.data.jpa.repository.EntityGraph;\n":""}
import ${this.packageName}.entity.${o};
${c}
/**
 * Repository interface for {@link ${o}} entity.
 * <p>Provides basic CRUD operations and custom queries.</p>
 */
@Repository
public interface ${o}Repository extends JpaRepository<${o}, ${s}> {

${m}    ${o} findOneBy${p}(${l});

${m}    Page<${o}> findAll(Specification<${o}> specification, Pageable pageable);
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`repository/${o}Repository.java`,content:u});let g=`package ${this.packageName}.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ${this.packageName}.entity.${o}Input;
${c}
/**
 * Repository interface for {@link ${o}Input} entity.
 * <p>Provides basic CRUD operations and custom queries for input version.</p>
 */
@Repository
public interface ${o}InputRepository extends JpaRepository<${o}Input, ${s}> {

    ${o}Input findOneBy${p}(${l});

    void deleteBy${p}(${l});
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`repository/${o}InputRepository.java`,content:g})}}),t}generateEntityFiles(){let e=this,t=this.model.entities,r=[];return t.forEach(t=>{let a=t.name,i=this.upperCamel(this.camelize(a)),o=this.snakeize(a),n=this.getPrimaryKeys(t),s=`package ${this.packageName}.entity;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PostLoad;
import jakarta.persistence.Table;

import lombok.Setter;
import lombok.Getter;

/**
 * Entity class representing the ${i} table in the database.
 * 
 * <p>This class is automatically generated by GraphQL Generator.</p>
 * <p>Contains fields for each column in the table, with appropriate annotations for JPA.</p>
 */
@Entity
@Table(name = "${o}")
@Setter
@Getter
`;n.length>1&&(s+=`@IdClass(${i}Id.class)
`),s+=`public class ${i} {

`;let p=[];t.columns.forEach(r=>{let a=r.name,i=this.camelize(a),o=r.type,l=this.getJavaType(o),c=i.substring(0,i.length-2),d=this.upperCamel(c);if(r.primaryKey&&(s+=`    @Id
`,r.autoIncrement&&(s+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),e.isForeignKey(e.model.entities,t,r)){s+=`    @Column(name = "${a}")
    private ${l} ${i};

`;s+=`    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "${r.name}", referencedColumnName = "${r.name}", insertable=false, updatable=false)
    private ${d} ${c};

`,p.push({name:c,type:d})}else s+=`    @Column(name = "${a}")
    private ${l} ${i};

`;n.length>1&&r.primaryKey&&!r.autoIncrement&&(s+=`    @ManyToOne
    @JoinColumn(name = "${a}", referencedColumnName = "${a}", insertable = false, updatable = false)
    private ${d} ${c};

`)}),p.length>0&&(s+=`
    @PostLoad
    public void initRelationsIfNull() {
`,p.forEach(e=>{s+=`        if (this.${e.name} == null) {
            this.${e.name} = new ${e.type}();
        }
`}),s+=`    }
`),s+=`}
`,r.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${i}.java`,content:s});let l=`package ${this.packageName}.entity;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.Table;

import lombok.Setter;
import lombok.Getter;

/**
 * Entity class representing the ${i} table in the database.
 * 
 * <p>This class is automatically generated by GraphQL Generator.</p>
 * <p>Contains fields for each column in the table, with appropriate annotations for JPA.</p>
 */
@Entity
@Table(name = "${o}")
@Setter
@Getter
`;n.length>1&&(l+=`@IdClass(${i}Id.class)
`),l+=`public class ${i}Input {

`,t.columns.forEach(e=>{let t=e.name,r=this.camelize(t),a=e.type,i=this.getJavaType(a);e.primaryKey&&(l+=`    @Id
`,e.autoIncrement&&(l+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),l+=`    @Column(name = "${t}")
    private ${i} ${r};

`}),l+=`}
`,r.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${i}Input.java`,content:l})}),r}generateFetchPropertiesFile(){let e=`package ${this.packageName}.utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import lombok.Getter;
import lombok.Setter;

/**
 * A utility class to manage and filter properties for data fetching operations.
 * It stores configurations for filtering and ordering fields, and provides
 * methods to ensure that requested fields are valid and supported.
 */
@Getter
@Setter
public class FetchProperties {
	
	private Map<String, Map<String, String>> filter;
	private List<Map<String, String>> order;
	
	public FetchProperties()
	{
		this.filter = new HashMap<>();
		this.order = new ArrayList<>();
	}

	/**
	 * Adds a field to the filter configuration.
	 *
	 * @param key The unique key for the filter (e.g., a field name).
	 * @param fieldName The actual name of the field in the entity.
	 * @param dataType The data type of the field (e.g., "String", "Long").
	 * @param filterType The type of filter operation (e.g., "exact", "partial").
	 */
	public void add(String key, String fieldName, String dataType, String filterType) {
		this.filter.put(key, this.createFilterType(fieldName, dataType, filterType));
	}

	/**
	 * Creates a map representing a single filter type configuration.
	 *
	 * @param fieldName The name of the field.
	 * @param dataType The data type of the field.
	 * @param filterType The filter operation type.
	 * @return A map containing the filter properties.
	 */
	private Map<String, String> createFilterType(String fieldName, String dataType, String filterType) {
		Map<String, String> field = new HashMap<>();
		
		field.put("fieldName", fieldName);
		field.put("dataType", dataType);
		field.put("filterType", filterType);
		
		return field;
	}

	/**
	 * Filters a list of data orders to include only those fields that are
	 * configured for filtering in this utility.
	 *
	 * @param dataOrder The list of data orders to filter.
	 * @return A new list containing only the valid data orders.
	 */
	public List<DataOrder> filterFieldName(List<DataOrder> dataOrder) {
		if(dataOrder == null)
		{
			return dataOrder;
		}
		List<DataOrder> result = new ArrayList<>();
		for(DataOrder order : dataOrder)
		{
			if(this.inList(order))
			{
				result.add(order);
			}
		}
		
		return result;
	}
	
	/**
	 * Checks if a given data order field is present in the configured filter list.
	 *
	 * @param order The DataOrder object to check.
	 * @return {@code true} if the field is in the filter list, {@code false} otherwise.
	 */
	public boolean inList(DataOrder order)
	{
		for(Entry<String, Map<String, String>> entry : this.filter.entrySet())
		{
			if(entry.getValue().getOrDefault("fieldName", "").equals(order.getFieldName()))
			{
				return true;
			}
		}
		return false;
	}
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/FetchProperties.java",content:e}]}generatePageUtilFile(){let e=`package ${this.packageName}.utils;

import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import java.util.List;
import java.util.ArrayList;
import java.util.Objects;

public class PageUtil {

    /**
     * Creates a Pageable object for paginated and sorted queries.
     *
     * @param pageNumber The 1-based page number. Defaults to 1 if null or less than 1.
     * @param pageSize The number of items per page. Defaults to 20, min is 1.
     * @param sortFields A list of maps, with each map containing "fieldName" and "sortType".
     * @param orderByFields An array of field names to sort by. Defaults to ascending.
     * @return A Pageable object configured with pagination and sorting.
     */
    public static Pageable pageRequest(Integer pageNumber, Integer pageSize, List<DataOrder> sortFields, String... orderByFields) {
        // Handle page number: convert to 0-based and ensure it's not negative.
        int currentPage = (pageNumber != null && pageNumber > 0) ? pageNumber - 1 : 0;
        
        // Handle page size: ensure it's at least 1.
        int rowPerPage = (pageSize != null && pageSize > 0) ? pageSize : 20;
        
        Sort sort = createSortFromList(sortFields);

        if (sort.isUnsorted() && orderByFields != null && orderByFields.length > 0) {
            sort = Sort.by(Direction.ASC, orderByFields);
        }
        
        return PageRequest.of(currentPage, rowPerPage, sort);
    }
    
    /**
     * Creates a {@link Sort} object from a list of maps, where each map
     * specifies a field to sort by and the sort direction.
     *
     * @param sortFields A list of maps, with each map containing "fieldName" and "sortType" (e.g., "asc" or "desc").
     * @return a Sort object representing the combined sorting criteria.
     */
    public static Sort createSortFromList(List<DataOrder> sortFields) {
        if (sortFields == null || sortFields.isEmpty()) {
            // Return unsorted object if no fields are provided
            return Sort.unsorted();
        }

        List<Order> orders = new ArrayList<>();
        for (DataOrder field : sortFields) {
            String fieldName = field.getFieldName();
            String orderTypeType = field.getOrderType();
            if(orderTypeType == null)
            {
            	orderTypeType = "asc";
            }

            if (fieldName != null && orderTypeType != null) {
                // Default direction is ASC
                Direction direction = Direction.ASC;
                if (Objects.equals(orderTypeType.toLowerCase(), "desc")) {
                    direction = Direction.DESC;
                }
                orders.add(new Order(direction, fieldName));
            }
        }
        
        // If the list of orders is empty after processing, return unsorted
        if (orders.isEmpty()) {
            return Sort.unsorted();
        }

        return Sort.by(orders);
    }


}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/PageUtil.java",content:e}]}isForeignKey(e,t,r){if(r.primaryKey)return!1;for(let a of e){if(a.name===t.name)continue;let i=this.getPrimaryKeys(a);for(let o of i)if(o.name===r.name)return!0}return!1}generateIdClassFiles(){let e=[];return this.model.entities.forEach(t=>{let r=this.getPrimaryKeys(t);if(r.length>1){let a=`${this.upperCamel(this.camelize(t.name))}Id`,i=`package ${this.packageName}.entity;

import java.io.Serializable;
import java.util.Objects;
import jakarta.persistence.Embeddable;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;

import lombok.Setter;
import lombok.Getter;

@Embeddable
@Setter
@Getter
public class ${a} implements Serializable {

`;r.forEach(e=>{let t=this.camelize(e.name),r=this.getJavaType(e.type);e.primaryKey&&(i+="",e.autoIncrement&&(i+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),i+=`    private ${r} ${t};

`}),i+=`    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ${a} that = (${a}) o;
        return ${r.map(e=>`Objects.equals(${this.camelize(e.name)}, that.${this.camelize(e.name)})`).join(" && ")};
    }

    @Override
    public int hashCode() {
        return Objects.hash(${r.map(e=>this.camelize(e.name)).join(", ")});
    }

`,i+=`}
`,e.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${a}.java`,content:i})}}),e}generateGraphQlSchema(){return[{name:"src/main/resources/graphql/schema.graphqls",content:GraphQLSchemaUtils.buildGraphQLSchema(this.model.entities,!1)}]}generatePomFile(){let e={groupId:this.groupId,artifactId:this.artifactId,version:this.version,name:this.serviceName,description:this.serviceDescription,javaVersion:this.javaVersion,packageName:this.packageName},t=`<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.5.4</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>
<groupId>${e.groupId}</groupId>
<artifactId>${e.artifactId}</artifactId>
<version>${e.version}</version>
<name>${e.name}</name>
<description>${e.description}</description>
<url/>
<licenses>
    <license/>
</licenses>
<developers>
    <developer/>
</developers>
<scm>
    <connection/>
    <developerConnection/>
    <tag/>
    <url/>
</scm>
<properties>
    <java.version>${e.javaVersion}</java.version>
</properties>
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-graphql</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <configuration>
                <annotationProcessorPaths>
                    <path>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                    </path>
                </annotationProcessorPaths>
            </configuration>
        </plugin>
        <plugin>
            <groupId>io.github.deweyjose</groupId>
            <artifactId>graphqlcodegen-maven-plugin</artifactId>
            <version>1.61.5</version>
            <executions>
                <execution>
                    <id>dgs-codegen</id>
                    <goals>
                        <goal>generate</goal>
                    </goals>
                    <configuration>
                        <schemaPaths>
                            <param>src/main/resources/graphql</param>
                        </schemaPaths>
                        <packageName>${e.packageName}.codegen</packageName>
                        <addGeneratedAnnotation>true</addGeneratedAnnotation>
                        <disableDatesInGeneratedAnnotation>true</disableDatesInGeneratedAnnotation>
                    </configuration>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>build-helper-maven-plugin</artifactId>
            <executions>
                <execution>
                    <id>add-dgs-source</id>
                    <phase>generate-sources</phase>
                    <goals>
                        <goal>add-source</goal>
                    </goals>
                    <configuration>
                        <sources>
                            <source>\${project.build.directory}/generated-sources</source>
                        </sources>
                    </configuration>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludes>
                    <exclude>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                    </exclude>
                </excludes>
            </configuration>
        </plugin>
    </plugins>
</build>

</project>
`;return[{name:"pom.xml",content:t}]}looksLikeSQLite(e){return[83,81,76,105,116,101,32,102,111,114,109,97,116,32,51,0].every((t,r)=>e[r]===t)}importSQLite(e,t){if(!e)return;let r=this,a=new FileReader;a.onload=function(e){let a=e.target.result,i=new Uint8Array(a);initSqlJs({locateFile:e=>"wasm/sql-wasm.wasm"}).then(e=>{r.db=new e.Database(i);let a=r.db.exec("SELECT name FROM sqlite_master WHERE type='table';"),o=[];a[0].values.forEach((e,t)=>{let a=e[0],i=new Entity(r.snakeize(a),t),n=r.db.exec(`SELECT * FROM ${a};`);if(n.length>0){let s=n[0].columns,p=n[0].values;i.creationDate=new Date().getTime(),i.modificationDate=i.creationDate,i.creator="{{userName}}",i.modifier="{{userName}}",i.data=p.map(e=>{let t={};return s.forEach((a,i)=>{let o=r.snakeize(a);t[o]=e[i]}),t})}else i.setData(null);let l=r.db.exec(`PRAGMA table_info(${a});`);l.length>0&&(l[0].values.forEach(e=>{let t="INTEGER"==e[2].toUpperCase()&&e[5],a=new Column(r.snakeize(e[1]),r.toMySqlType(e[2]),r.getColumnSize(e[2]),1===e[3],e[4],e[5],t,null);i.addColumn(a)}),o.push(i))}),"function"==typeof t&&t({entities:o})})},a.readAsArrayBuffer(e)}importSQLQuery(e,t){let r=this,a=new FileReader;a.onload=function(e){let a=e.target.result;try{let i=new SQLConverter,o=i.translate(a,"mysql").replace(/`/g,""),n=new TableParser(o);n.parseData(a);let s=r.createEntitiesFromSQL(n.tableInfo);"function"==typeof t&&t({entities:s})}catch(p){console.log("Error parsing SQL: "+p.message)}},a.onerror=()=>{},a.readAsText(e)}createEntitiesFromSQL(e){let t=[];return e.forEach((e,r)=>{let a=new Entity(e.tableName,r);e.columns.forEach(e=>{let t=new Column(e.Field,e.Type.toUpperCase(),e.Length,e.Nullable,e.Default,e.Key,e.AutoIncrement,null!=e.EnumValues&&"object"==typeof e.EnumValues?e.EnumValues.join(", "):null,null);a.addColumn(t)}),a.creationDate=new Date().getTime(),a.modificationDate=a.creationDate,a.creator="{{userName}}",a.modifier="{{userName}}",t.push(a)}),t}importSQLFile(e,t){let r=this,a=new FileReader,i=e.slice(0,512);a.onload=function(a){let i=new Uint8Array(a.target.result);r.looksLikeSQLite(i)?r.importSQLite(e,t):r.importSQLQuery(e,t)},a.onerror=()=>{},a.readAsArrayBuffer(i)}toMySqlType(e){if(!e)return"TEXT";let t=e.trim().toUpperCase();for(let[r,a]of[[/NVARCHAR/,"VARCHAR"],[/INT/,"BIGINT"],[/(CHAR|CLOB|TEXT)/,"TEXT"],[/BLOB/,"BLOB"],[/(REAL|FLOA|DOUB)/,"DOUBLE"],[/(NUMERIC|DECIMAL)/,"DECIMAL"],[/BOOLEAN/,"TINYINT"],[/TIMESTAMP/,"TIMESTAMP"],[/(DATE|TIME)/,"DATETIME"]])if(r.test(t))return a;return e}getColumnSize(e){if(!e)return null;if(-1!==e.toUpperCase().indexOf("BOOL"))return 1;let t=e.match(/\((\d+)\)/);return t&&t[1]?parseInt(t[1]):null}toValidTableName(e){return e.replace(/\.[^/.]+$/,"").replace(/[^a-zA-Z0-9]+/g,"_").toLowerCase().replace(/^_+|_+$/g,"")}getDataType(e){if(null==e)return"String";switch(e.toUpperCase()){case"CHAR":case"VARCHAR":case"TEXT":case"LONGTEXT":case"MEDIUMTEXT":default:return"String";case"TINYINT":case"SMALLINT":case"MEDIUMINT":case"INT":return"Integer";case"BIGINT":return"Long";case"FLOAT":return"Float";case"DOUBLE":case"DECIMAL":return"Double";case"BOOLEAN":return"Boolean";case"DATE":return"Date";case"DATETIME":case"TIMESTAMP":return"DateTime"}}getFilterType(e){return null==e||"String"===e?"partial":"exact"}}