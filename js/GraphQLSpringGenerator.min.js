class GraphQLSpringGenerator{constructor(){this.packageName=null,this.groupId=null,this.artifactId=null,this.serviceName=null,this.serviceDescription=null,this.javaVersion=null,this.version=null,this.maxRelationDepth=3,this.model=null}generateVirtualFiles(){let e={port:parseInt(document.querySelector("#appPort").value.trim(),10)},t={url:document.querySelector("#dbUrl").value.trim(),username:document.querySelector("#dbUsername").value.trim(),password:document.querySelector("#dbPassword").value,driver:document.querySelector("#dbDriver").value.trim(),showSql:"true"===document.querySelector("#dbShowSql").value,dialect:document.querySelector("#dbDialect").value.trim()},a=[];return a.push(...this.generateIdClassFiles()),a.push(...this.generateEntityFiles()),a.push(...this.generateRepositoryFiles()),a.push(...this.generateConnectionFiles()),a.push(...this.generateServiceFiles()),a.push(...this.generateControllerFiles()),a.push(...this.generateGraphQlSchema()),a.push(...this.generatePageInfoFile()),a.push(...this.generatePomFile()),a.push(...this.generateApplicationFile()),a.push(...this.generateCorsConfigFile()),a.push(...this.generateRequestInterceptorFile()),a.push(...this.generateDataFilterFile()),a.push(...this.generateDataOrderFile()),a.push(...this.generateFetchPropertiesFile()),a.push(...this.generateSpecificationUtilFile()),a.push(...this.generatePageUtilFile()),a.push(...this.generateApplicationPropertiesFile(e,t)),a.push(...Maven.generateMavenFile()),a.push(...Maven.generateMavenCmdFile()),a.push(...Maven.generateMavenWrapperFiles()),a}async createZipFile(e,t={},a="servicegen.zip"){this.packageName=t.packageName||"com.example.servicegen",this.groupId=t.groupId||"com.example",this.artifactId=t.artifactId||"servicegen",this.serviceName=t.serviceName||"Service Generator",this.serviceDescription=t.serviceDescription||"A service generator for Spring GraphQL",this.javaVersion=t.javaVersion||"21",this.version=t.version||"1.0.0",this.maxRelationDepth=3,this.model=e;let r=document.getElementById("loading");r.style.display="block";let i=this.generateVirtualFiles();if(0===i.length){alert("Tidak ada file untuk dikompresi."),r.style.display="none";return}let n=new JSZip;for(let o of i)n.file(o.name,o.content);try{let p=await n.generateAsync({type:"blob"});saveAs(p,a)}catch(s){console.error("Gagal membuat file ZIP:",s)}finally{r.style.display="none"}}getPrimaryKeys(e){return e.columns.filter(e=>e.primaryKey)}getPrimatyKey(e){let t=e.columns.find(e=>e.primaryKey);return t?{primaryKeyName:t.name,primaryKeyCamel:stringUtil.camelize(t.name),primaryKeyType:t.type,primaryKeyJavaType:this.getJavaType(t.type)}:null}getJavaType(e){let t=e.toLowerCase();if(-1!==t.indexOf("int")||-1!==t.indexOf("integer")||-1!==t.indexOf("tinyint")||-1!==t.indexOf("long")||-1!==t.indexOf("bigint"))return"Long";if(-1!==t.indexOf("string")||-1!==t.indexOf("varchar")||-1!==t.indexOf("text"))return"String";if(-1!==t.indexOf("boolean"))return"Boolean";if(-1!==t.indexOf("date")||-1!==t.indexOf("timestamp"))return"Date";else if(-1!==t.indexOf("double")||-1!==t.indexOf("float"))return"Double";else if(-1!==t.indexOf("uuid"))return"UUID";else if(-1!==t.indexOf("bigdecimal"))return"BigDecimal";else if(-1!==t.indexOf("number")||-1!==t.indexOf("real")||-1!==t.indexOf("decimal")||-1!==t.indexOf("numeric"))return"Double";return"Object"}createSourceDirectoryFromArtefact(e){return"src/main/java/"+e.split(".").join("/")+"/"}generateApplicationFile(){let e=`package ${this.packageName};

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"Application.java",content:e}]}generateApplicationPropertiesFile(e,t){let a=`# Spring Boot application properties
# Server port
server.port=${e.port||8080}
# Database configuration
spring.datasource.url=${t.url||"jdbc:mysql://localhost:3306/mydb"}
spring.datasource.username=${t.username||"root"}
spring.datasource.password=${t.password||""}
spring.datasource.driver-class-name=${t.driver||"com.mysql.cj.jdbc.Driver"}
# JPA/Hibernate configuration
spring.jpa.show-sql=${t.showSql||"true"}
spring.jpa.properties.hibernate.dialect=${t.dialect}
# GraphQL configuration
spring.graphql.schema-location=classpath:graphql/schema.graphqls
# Logging configuration
logging.level.org.springframework=INFO
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
# Application name and description
spring.application.name=${this.serviceName}
spring.application.description=${this.serviceDescription}
# Java version
spring.java.version=${this.javaVersion}
# Package name
spring.package.name=${this.packageName}
# Version
spring.application.version=${this.version}
`;return[{name:"src/main/resources/application.properties",content:a}]}generateRequestInterceptorFile(){let e=`package ${this.packageName}.config;

import java.net.InetAddress;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import org.springframework.graphql.server.WebGraphQlInterceptor;
import org.springframework.graphql.server.WebGraphQlRequest;
import org.springframework.graphql.server.WebGraphQlResponse;
import org.springframework.stereotype.Component;
import org.springframework.util.MultiValueMap;
import org.springframework.util.MultiValueMapAdapter;

import reactor.core.publisher.Mono;

/**
 * The GraphQLRequestInterceptor is a Spring component that intercepts every GraphQL request.
 * It is responsible for capturing and storing important request metadata such as the client's
 * IP address, HTTP headers, and the raw GraphQL query into the GraphQLContext.
 *
 * By storing this data in the GraphQLContext, it can be accessed by any DataFetcher or
 * resolver during query execution. This enables functionalities like logging, auditing,
 * or context-based validation.
 */
@Component
public class GraphQLRequestInterceptor implements WebGraphQlInterceptor {
    /**
     * Intercepts an incoming GraphQL request and adds metadata to its GraphQLContext.
     *
     * @param request The incoming GraphQL request.
     * @param chain   The interceptor chain used to pass the request along.
     * @return A Mono<WebGraphQlResponse> representing the response after execution.
     */
    @Override
    public Mono<WebGraphQlResponse> intercept(WebGraphQlRequest request, Chain chain) {
        Map<String, String> headers = request.getHeaders().toSingleValueMap();
        String clientIp = Optional.ofNullable(request.getRemoteAddress())
                .map(addr -> addr.getAddress())
                .map(InetAddress::getHostAddress)
                .orElse("UNKNOWN");
        String path = request.getUri().getPath();
        MultiValueMap<String, String> queryParams = request.getUri().getQueryParams();
        
        Map<String, String> queryParamsFlat = Optional.ofNullable(queryParams).orElse(new MultiValueMapAdapter<>(new HashMap<>())).toSingleValueMap();
        
        String graphqlQuery = Optional.ofNullable(request.getDocument()).orElse("");

        Map<String, Object> contextMap = new HashMap<>();
        contextMap.put("clientIp", clientIp);
        contextMap.put("headers", headers);
        contextMap.put("path", path);
        contextMap.put("queryParams", queryParamsFlat);
        contextMap.put("graphqlQuery", graphqlQuery);

        request.configureExecutionInput((executionInput, builder) ->
                builder.graphQLContext(contextMap).build()
        );

        return chain.next(request);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"config/GraphQLRequestInterceptor.java",content:e}]}generateCorsConfigFile(){let e=`package ${this.packageName}.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/graphql/**") 
                .allowedOrigins("*") 
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*");
    }
}`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"config/CorsConfig.java",content:e}]}generateControllerFiles(){let e=this.model.entities,t=[];return e.forEach(e=>{let a=e.name,r=stringUtil.camelize(a),i=stringUtil.upperCamel(r),n=this.getPrimaryKeys(e);if(n.length>0){let o=n.map(e=>`@Argument ${this.getJavaType(e.type)} ${stringUtil.camelize(e.name)}`).join(", "),p=n.map(e=>stringUtil.camelize(e.name)).join(", "),s=`package ${this.packageName}.controller;

import java.util.List;

import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.stereotype.Controller;

import ${this.packageName}.output.${i}Connection;
import ${this.packageName}.utils.DataFilter;
import ${this.packageName}.utils.DataOrder;
import ${this.packageName}.dto.${i}Create;
import ${this.packageName}.dto.${i}Update;
import ${this.packageName}.entity.${i};
import ${this.packageName}.service.${i}Service;

import graphql.schema.DataFetchingEnvironment;

import lombok.RequiredArgsConstructor;

@Controller
@RequiredArgsConstructor
public class ${i}Controller {

    private final ${i}Service ${r}Service;

    @QueryMapping
    public ${i}Connection get${i}s(@Argument(name = "pageNumber") Integer pageNumber, @Argument(name = "pageSize") Integer pageSize, @Argument(name = "dataFilter") List<DataFilter> dataFilter, @Argument(name = "dataOrder") List<DataOrder> dataOrder, DataFetchingEnvironment env) {
        return ${r}Service.get${i}s(pageNumber, pageSize, dataFilter, dataOrder);
    }

    @QueryMapping
    public ${i} get${i}(${o}, DataFetchingEnvironment env) {
        return ${r}Service.get${i}(${p});
    }

    @MutationMapping
    public ${i} create${i}(@Argument ${i}Create input, DataFetchingEnvironment env) {
        return ${r}Service.create${i}(input);
    }

    @MutationMapping
    public ${i} update${i}(@Argument ${i}Update input, DataFetchingEnvironment env) {
        return ${r}Service.update${i}(input);
    }

    @MutationMapping
    public Boolean delete${i}(${o}, DataFetchingEnvironment env) {
        ${r}Service.delete${i}(${p});
        return true;
    }
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`controller/${i}Controller.java`,content:s})}}),t}generateServiceFiles(){let e=this,t=this.model.entities,a=[];return t.forEach(t=>{let r=t.name,i=stringUtil.camelize(r),n=stringUtil.upperCamel(i),o=this.getPrimaryKeys(t),p="";t.columns.forEach(t=>{let a=e.getDataType(t.type),r=e.getFilterType(a),i=stringUtil.camelize(t.name);p+=`		this.queryPredicateMapping.add("${i}", "${i}", "${a}", "${r}");\r
`});let s="";if(o.length>0){let l=o.map(e=>`${this.getJavaType(e.type)} ${stringUtil.camelize(e.name)}`).join(", "),c=o.map(e=>stringUtil.camelize(e.name)).join(", "),g='"'+o.map(e=>stringUtil.camelize(e.name)).join('", "')+'"',u=o.map(e=>stringUtil.upperCamel(stringUtil.camelize(e.name))).join("And"),m=[];o.forEach(e=>{let t=stringUtil.upperCamel(stringUtil.camelize(e.name));m.push(`input.get${t}() == null`),e.primaryKey&&e.autoIncrement&&(s=`\r
		input.set${t}(null);`)});let d=`package ${this.packageName}.service;

import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import lombok.RequiredArgsConstructor;

import ${this.packageName}.dto.${n}Create;
import ${this.packageName}.dto.${n}Update;
import ${this.packageName}.entity.${n};
import ${this.packageName}.entity.${n}Input;
import ${this.packageName}.output.${n}Connection;
import ${this.packageName}.repository.${n}Repository;
import ${this.packageName}.repository.${n}InputRepository;
import ${this.packageName}.utils.DataFilter;
import ${this.packageName}.utils.DataOrder;
import ${this.packageName}.utils.QueryPredicateMapping;
import ${this.packageName}.utils.PageUtil;
import ${this.packageName}.utils.SpecificationUtil;

import jakarta.annotation.PostConstruct;
import jakarta.transaction.Transactional;

/**
 * Service class for handling business logic and CRUD operations 
 * for the {@link ${n}} entity.
 *
 * <p>This service provides methods to query, create, update, and delete 
 * records from the database using the associated repository.</p>
 *
 * <p>Generated automatically by GraphQL Generator.</p>
 */
@Service
@RequiredArgsConstructor
public class ${n}Service {

    private final ${n}Repository ${i}Repository;
    private final ${n}InputRepository ${i}InputRepository;

    private QueryPredicateMapping queryPredicateMapping;
    
    @PostConstruct
    public void init()
    {
    	queryPredicateMapping = new QueryPredicateMapping();
    	
${p}
    }
    
    /**
     * Retrieves a paginated and optionally filtered list of {@link ${n}} records from the database.
     * This method supports dynamic filtering and sorting based on the provided criteria,
     * and wraps the result in an {@link ${n}Connection} for pagination support.
     *
     * @param pageNumber the 1-based page number for pagination (required).
     * @param pageSize the number of records to retrieve per page (required).
     * @param dataFilter an optional list of filters to be applied to the query (may be {@code null} or empty).
     * @param dataOrder an optional list of fields and their sort order to be applied to the query (may be {@code null} or empty).
     * @return {@link ${n}Connection} object containing the paginated {@link ${n}} records
     *         that match the given filtering and sorting criteria.
     */
    public ${n}Connection get${n}s(Integer pageNumber, Integer pageSize, List<DataFilter> dataFilter, List<DataOrder> dataOrder) {
        Page<${n}> page = ${i}Repository.findAll(
        		SpecificationUtil.createSpecificationFromFilter(dataFilter, this.queryPredicateMapping.getFilter()), 
        		PageUtil.pageRequest(pageNumber, pageSize, dataOrder, this.queryPredicateMapping.getFilter(), Sort.by(Sort.Direction.ASC, ${g}))
        );
        return new ${n}Connection(page);
    }

    /**
     * Retrieves ${n} record matching the given primary key.
     *
     * @param ${o.map(e=>stringUtil.camelize(e.name)).join(", ")} the primary key value(s) used for filtering.
     * @return a list of matching ${n} entities.
     */
    public ${n} get${n}(${l}) {
        return ${i}Repository.findOneBy${u}(${c});
    }

    /**
     * Creates a new record for {@link ${n}} in the database.
     *
     * @param input the ${n} entity to be created.
     * @return the saved ${n} entity.
     */
    public ${n} create${n}(${n}Create input) {
        ${n}Input saved = ${i}InputRepository.save(${n}Create.createEntity(input));
        return ${i}Repository.findOneBy${u}(
            ${o.map(e=>`saved.get${stringUtil.upperCamel(stringUtil.camelize(e.name))}()`).join(", ")}
        );
    }

    /**
     * Updates an existing {@link ${n}} record in the database.
     *
     * @param input the ${n} entity containing updated values.
     * @return the updated ${n} entity.
     */
    public ${n} update${n}(${n}Update input) {
        if(${m.join(" || ")})
    	{
    		return null;
    	}
        ${n}Input saved = ${i}InputRepository.save(${n}Update.createEntity(input));
        return ${i}Repository.findOneBy${u}(
            ${o.map(e=>`saved.get${stringUtil.upperCamel(stringUtil.camelize(e.name))}()`).join(", ")}
        );
    }

    /**
     * Deletes the {@link ${n}} record that matches the given primary key(s).
     *
     * @param ${o.map(e=>stringUtil.camelize(e.name)).join(", ")} the primary key value(s) of the record to delete.
     */
    @Transactional
    public void delete${n}(${l}) {
        ${i}InputRepository.deleteBy${u}(${c});
    }
}
`;a.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`service/${n}Service.java`,content:d})}}),a}gereratePageUtilFile(){let e=`package ${this.packageName}.utils;

import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;

public class PageUtil {

    /**
     * Creates a Pageable object for paginated and sorted queries.
     *
     * @param pageNumber The 1-based page number. Defaults to 1 if null or less than 1.
     * @param pageSize The number of items per page. Defaults to 20, min is 1.
     * @param orderByFields An array of field names to sort by. Defaults to ascending.
     * @return A Pageable object configured with pagination and sorting.
     */
    public static Pageable pageRequest(Integer pageNumber, Integer pageSize, String... orderByFields) {
        // Handle page number: convert to 0-based and ensure it's not negative.
        int currentPage = (pageNumber != null && pageNumber > 0) ? pageNumber - 1 : 0;
        
        // Handle page size: ensure it's at least 1.
        int rowPerPage = (pageSize != null && pageSize > 0) ? pageSize : 20;

        // Create Sort object if orderByFields are provided
        Sort sort = Sort.unsorted();
        if (orderByFields != null && orderByFields.length > 0) {
            sort = Sort.by(Direction.ASC, orderByFields);
        }
        
        return PageRequest.of(currentPage, rowPerPage, sort);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/PageUtil.java",content:e}]}generateSpecificationUtilFile(){let e=`package ${this.packageName}.utils;

import jakarta.persistence.criteria.Path;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Root;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;

import org.springframework.data.jpa.domain.Specification;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class for creating dynamic JPA Specifications from DataFilters.
 * This class provides a generic method that can be used for any entity type.
 */
public class SpecificationUtil {

    private SpecificationUtil()
    {
        // Hide public constructor
    }

    private static final Logger logger = LoggerFactory.getLogger(SpecificationUtil.class);
    private static final String DATE_FORMAT = "yyyy-MM-dd";
    private static final String DATETIME_FORMAT = "yyyy-MM-dd'T'HH:mm:ss";

    /**
     * Creates a generic {@link Specification} from a list of {@link DataFilter} to build dynamic queries.
     * This method supports various filtering types based on the provided filterType map.
     *
     * @param dataFilter list of filters to apply.
     * @param filterType a map defining the data type and filter type for each field.
     * @param <T> The entity type to be filtered.
     * @return a Specification object representing the combined filters.
     */
    public static <T> Specification<T> createSpecificationFromFilter(List<DataFilter> dataFilter, Map<String, Map<String, String>> filterType) {
        if (dataFilter == null || dataFilter.isEmpty() || filterType == null) {
            return null;
        }

        Specification<T> spec = Specification.where(null);

        for (DataFilter filter : dataFilter) {
            String key = filter.getFieldName();
            String fieldValue = filter.getFieldValue();

            if (key != null && fieldValue != null) {
                Map<String, String> fieldInfo = filterType.get(key);

                if (fieldInfo != null) {
                    String fieldName = fieldInfo.get("fieldName");
                    String dataType = fieldInfo.get("dataType");
                    String filterOperation = fieldInfo.get("filterType");

                    spec = spec.and((root, query, criteriaBuilder) -> {
                        try {
                            Path<?> path = resolvePath(root, fieldName);
                            
                            switch (dataType) {
                                case "Long":
                                    return criteriaBuilder.equal(path, Long.parseLong(fieldValue));
                                case "Integer":
                                    return criteriaBuilder.equal(path, Integer.parseInt(fieldValue));
                                case "Double":
                                case "Float":
                                    return criteriaBuilder.equal(path, Double.parseDouble(fieldValue));
                                case "Boolean":
                                    return criteriaBuilder.equal(path, Boolean.parseBoolean(fieldValue));
                                case "Date":
                                    Date date = new SimpleDateFormat(DATE_FORMAT).parse(fieldValue);
                                    return criteriaBuilder.equal(path, date);
                                case "DateTime":
                                    Date dateTime = new SimpleDateFormat(DATETIME_FORMAT).parse(fieldValue);
                                    return criteriaBuilder.equal(path, dateTime);
                                case "String":
                                    if ("exact".equals(filterOperation)) {
                                        return criteriaBuilder.equal(path, fieldValue);
                                    } else if ("partial".equals(filterOperation)) {
                                        return criteriaBuilder.like(criteriaBuilder.lower((Path<String>) path), "%" + fieldValue.toLowerCase() + "%");
                                    }
                                    break;
                                default:
                                    // Handle unsupported data types
                                    break;
                            }
                        } catch (Exception e) {
                            logger.error("Error creating predicate for field {}: {}", fieldName, e.getMessage());
                        }
                        return criteriaBuilder.disjunction(); // Return a false predicate on error
                    });
                }
            }
        }
        return spec;
    }

    /**
     * Helper method to resolve a nested path by performing joins.
     * This method handles both direct attributes and nested attributes with multiple dots.
     *
     * @param root The root of the query.
     * @param fieldName The dot-separated field name (e.g., "album.artist.name").
     * @return The final Path object to the attribute.
     */
    private static Path<?> resolvePath(Root<?> root, String fieldName) {
        String[] parts = fieldName.split("\\\\.");
        Path<?> path = root;

        // Iterate through all parts of the path
        for (int i = 0; i < parts.length - 1; i++) {
            // Cast to Join is needed to continue the path, but only if the current path is not the root
            if (path instanceof Root) {
                 path = ((Root<?>) path).join(parts[i]);
            } else {
                 path = ((Join<?, ?>) path).join(parts[i]);
            }
        }
        
        // Return the final Path to the attribute
        return path.get(parts[parts.length - 1]);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/SpecificationUtil.java",content:e}]}generateDataFilterFile(){let e=`package ${this.packageName}.utils;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class DataFilter {
	String fieldName;
	String fieldValue;
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/DataFilter.java",content:e}]}generateDataOrderFile(){let e=`package ${this.packageName}.utils;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class DataOrder {
	String fieldName;
	String orderType;
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/DataOrder.java",content:e}]}getNestedRelations(e,t,a="",r=2){if(r<=0)return[];let i=[],n=this.getPrimaryKeys(t).length>1;return t.columns.forEach(o=>{if(this.isForeignKey(e,t,o)&&!n){let p=stringUtil.camelize(o.name.replace(/_id$/i,"")),s=a?`${a}.${p}`:p;i.push(s);let l=e.find(e=>e.name.toLowerCase()===p.toLowerCase());l&&i.push(...this.getNestedRelations(e,l,s,r-1))}}),t.columns.forEach(t=>{if(n){let o=stringUtil.camelize(t.name.replace(/_id$/i,"")),p=a?`${a}.${o}`:o;i.push(p);let s=e.find(e=>e.name.toLowerCase()===o.toLowerCase());s&&i.push(...this.getNestedRelations(e,s,p,r-1))}}),i}generateConnectionFiles(){let e=this.model.entities,t=[];return e.forEach(e=>{let a=stringUtil.camelize(e.name),r=stringUtil.upperCamel(a),i=`package ${this.packageName}.output;

import org.springframework.data.domain.Page;

import ${this.packageName}.entity.${r};
import ${this.packageName}.utils.PageInfo;

/**
 * A connection wrapper for paginated {@link ${r}} results.
 * <p>
 * This class encapsulates both the paginated list of {@link ${r}} entities
 * and pagination metadata via {@link PageInfo}.
 * It is commonly used as a GraphQL-compatible representation of
 * paginated query results.
 * </p>
 */
public class ${r}Connection
{
    /**
     * Pagination metadata, including total records, total pages,
     * current page number, and page size.
     */
    private PageInfo pageInfo;

    /**
     * The underlying paginated data of {@link ${r}} entities.
     */
    private Page<${r}> data;

    /**
     * Constructs a new {@code ${r}Connection} from a Spring Data {@link Page}.
     * <p>
     * The {@link PageInfo} is initialized from the provided {@link Page}
     * to represent pagination details.
     * </p>
     *
     * @param page the {@link Page} of {@link ${r}} entities to wrap.
     */
    public ${r}Connection(Page<${r}> page)
    {
        this.data = page;
        this.pageInfo = new PageInfo(page);
    }
}

`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`output/${r}Connection.java`,content:i})}),t}generateRepositoryFiles(){let e=this.model.entities,t=[],a=this;return e.forEach(r=>{let i=stringUtil.camelize(r.name),n=stringUtil.upperCamel(i),o=this.getPrimaryKeys(r);if(o.length>0){let p=o.length>1?`${n}Id`:this.getJavaType(o[0].type),s=o.map(e=>stringUtil.upperCamel(stringUtil.camelize(e.name))).join("And"),l=o.map(e=>`${this.getJavaType(e.type)} ${stringUtil.camelize(e.name)}`).join(", "),c="";["String","Long","Integer","Double","Float","Boolean","Character","Byte","Short"].includes(p)||p.includes(".")||(c=`import ${this.packageName}.entity.${p};
`);let g=this.getNestedRelations(e,r,"",a.maxRelationDepth||3),u="";(g.length>0||o.length>1)&&(u=`    @EntityGraph(attributePaths = { ${g.map(e=>`"${e}"`).join(", ")} })
`);let m=`package ${this.packageName}.repository;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
${g.length>0?"import org.springframework.data.jpa.repository.EntityGraph;\n":""}
import ${this.packageName}.entity.${n};
${c}
/**
 * Repository interface for {@link ${n}} entity.
 * <p>Provides basic CRUD operations and custom queries.</p>
 */
@Repository
public interface ${n}Repository extends JpaRepository<${n}, ${p}> {

${u}    ${n} findOneBy${s}(${l});

${u}    Page<${n}> findAll(Specification<${n}> specification, Pageable pageable);
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`repository/${n}Repository.java`,content:m});let d=`package ${this.packageName}.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ${this.packageName}.entity.${n}Input;
${c}
/**
 * Repository interface for {@link ${n}Input} entity.
 * <p>Provides basic CRUD operations and custom queries for input version.</p>
 */
@Repository
public interface ${n}InputRepository extends JpaRepository<${n}Input, ${p}> {

    ${n}Input findOneBy${s}(${l});

    void deleteBy${s}(${l});
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`repository/${n}InputRepository.java`,content:d})}}),t}generateEntityFiles(){let e=this,t=this.model.entities,a=[];return t.forEach(t=>{let r=t.name,i=stringUtil.upperCamel(stringUtil.camelize(r)),n=stringUtil.snakeize(r),o=this.getPrimaryKeys(t),p=`package ${this.packageName}.entity;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PostLoad;
import jakarta.persistence.Table;

import lombok.Setter;
import lombok.Getter;

/**
 * Entity class representing the ${i} table in the database.
 * 
 * <p>This class is automatically generated by GraphQL Generator.</p>
 * <p>Contains fields for each column in the table, with appropriate annotations for JPA.</p>
 */
@Entity
@Table(name = "${n}")
@Setter
@Getter
`;o.length>1&&(p+=`@IdClass(${i}Id.class)
`),p+=`public class ${i} {

`;let s=[];t.columns.forEach(a=>{let r=a.name,i=stringUtil.camelize(r),n=a.type,l=this.getJavaType(n),c=i.substring(0,i.length-2),g=stringUtil.upperCamel(c);if(a.primaryKey&&(p+=`    @Id
`,a.autoIncrement&&(p+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),e.isForeignKey(e.model.entities,t,a)){p+=`    @Column(name = "${r}")
    private ${l} ${i};

`;p+=`    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "${a.name}", referencedColumnName = "${a.name}", insertable=false, updatable=false)
    private ${g} ${c};

`,s.push({name:c,type:g})}else p+=`    @Column(name = "${r}")
    private ${l} ${i};

`;o.length>1&&a.primaryKey&&!a.autoIncrement&&(p+=`    @ManyToOne
    @JoinColumn(name = "${r}", referencedColumnName = "${r}", insertable = false, updatable = false)
    private ${g} ${c};

`)}),s.length>0&&(p+=`
    @PostLoad
    public void initRelationsIfNull() {
`,s.forEach(e=>{p+=`        if (this.${e.name} == null) {
            this.${e.name} = new ${e.type}();
        }
`}),p+=`    }
`),p+=`}
`,a.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${i}.java`,content:p});let l=`package ${this.packageName}.entity;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.Table;

import lombok.Setter;
import lombok.Getter;

/**
 * Entity class representing the ${i} table in the database.
 * 
 * <p>This class is automatically generated by GraphQL Generator.</p>
 * <p>Contains fields for each column in the table, with appropriate annotations for JPA.</p>
 */
@Entity
@Table(name = "${n}")
@Setter
@Getter
`;o.length>1&&(l+=`@IdClass(${i}Id.class)
`),l+=`public class ${i}Input {

`,t.columns.forEach(e=>{let t=e.name,a=stringUtil.camelize(t),r=e.type,i=this.getJavaType(r);e.primaryKey&&(l+=`    @Id
`,e.autoIncrement&&(l+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),l+=`    @Column(name = "${t}")
    private ${i} ${a};

`}),l+=`}
`,a.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${i}Input.java`,content:l});let c=`package ${this.packageName}.dto;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;

import lombok.Setter;
import lombok.Getter;

import org.springframework.beans.BeanUtils;

import ${this.packageName}.entity.${i}Input;

/**
 * Data Transfer Object (DTO) for creating a new ${i} entity.
 *
 * <p>This class is automatically generated by GraphQL Generator.</p>
 *
 * <p>It represents the input fields required by the CREATE mutation of the
 * {@code ${n}} table. The DTO can be converted into an {@link ${i}Input}
 * entity using the {@link #createEntity(${i}Create)} factory method.</p>
 */
@Setter
@Getter
`;c+=`public class ${i}Create {

`,t.columns.forEach(e=>{let t=e.name,a=stringUtil.camelize(t),r=e.type,i=this.getJavaType(r);e.autoIncrement||(c+=`    private ${i} ${a};
`)}),c+=`\r
    /**
     * Converts this DTO into a new {@link ${i}Input} entity.
     *
     * @param dto the {@code ${i}Create} DTO to convert
     * @return a new {@code ${i}Input} entity populated with values from the DTO
     */
    public static ${i}Input createEntity(${i}Create dto) {
        ${i}Input entity = new ${i}Input();
        BeanUtils.copyProperties(dto, entity);
        return entity;
    }
`,c+=`}
`,a.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`dto/${i}Create.java`,content:c});let g=`package ${this.packageName}.dto;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;

import lombok.Setter;
import lombok.Getter;

import org.springframework.beans.BeanUtils;

import ${this.packageName}.entity.${i}Input;

/**
 * Data Transfer Object (DTO) for updating an existing ${i} entity.
 *
 * <p>This class is automatically generated by GraphQL Generator.</p>
 *
 * <p>It represents the input fields required by the UPDATE mutation of the
 * {@code ${n}} table. The DTO can be converted into an {@link ${i}Input}
 * entity using the {@link #createEntity(${i}Create)} factory method.</p>
 */
@Setter
@Getter
`;g+=`public class ${i}Update {

`,t.columns.forEach(e=>{let t=e.name,a=stringUtil.camelize(t),r;g+=`    private ${this.getJavaType(e.type)} ${a};
`}),g+=`\r
    /**
     * Converts this DTO into a new {@link ${i}Input} entity.
     *
     * @param dto the {@code ${i}Update} DTO to convert
     * @return a new {@code ${i}Input} entity populated with values from the DTO
     */
    public static ${i}Input createEntity(${i}Update dto) {
        ${i}Input entity = new ${i}Input();
        BeanUtils.copyProperties(dto, entity);
        return entity;
    }
`,g+=`}
`,a.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`dto/${i}Update.java`,content:g})}),a}generateFetchPropertiesFile(){let e=`package ${this.packageName}.utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import lombok.Getter;
import lombok.Setter;

/**
 * A utility class to manage and filter properties for data fetching operations.
 * It stores configurations for filtering and ordering fields, and provides
 * methods to ensure that requested fields are valid and supported.
 */
@Getter
@Setter
public class QueryPredicateMapping {
	
	private Map<String, Map<String, String>> filter;
	private List<Map<String, String>> order;
	
	public QueryPredicateMapping()
	{
		this.filter = new HashMap<>();
		this.order = new ArrayList<>();
	}

	/**
	 * Adds a field to the filter configuration.
	 *
	 * @param key The unique key for the filter (e.g., a field name).
	 * @param fieldName The actual name of the field in the entity.
	 * @param dataType The data type of the field (e.g., "String", "Long").
	 * @param filterType The type of filter operation (e.g., "exact", "partial").
	 */
	public void add(String key, String fieldName, String dataType, String filterType) {
		this.filter.put(key, this.createFilterType(fieldName, dataType, filterType));
	}

	/**
	 * Creates a map representing a single filter type configuration.
	 *
	 * @param fieldName The name of the field.
	 * @param dataType The data type of the field.
	 * @param filterType The filter operation type.
	 * @return A map containing the filter properties.
	 */
	private Map<String, String> createFilterType(String fieldName, String dataType, String filterType) {
		Map<String, String> field = new HashMap<>();
		
		field.put("fieldName", fieldName);
		field.put("dataType", dataType);
		field.put("filterType", filterType);
		
		return field;
	}

	/**
	 * Filters a list of data orders to include only those fields that are
	 * configured for filtering in this utility.
	 *
	 * @param dataOrder The list of data orders to filter.
	 * @return A new list containing only the valid data orders.
	 */
	public List<DataOrder> filterFieldName(List<DataOrder> dataOrder) {
		if(dataOrder == null)
		{
			return dataOrder;
		}
		List<DataOrder> result = new ArrayList<>();
		for(DataOrder item : dataOrder)
		{
			if(this.inList(item))
			{
				result.add(item);
			}
		}
		
		return result;
	}
	
	/**
	 * Checks if a given data order field is present in the configured filter list.
	 *
	 * @param order The DataOrder object to check.
	 * @return {@code true} if the field is in the filter list, {@code false} otherwise.
	 */
	public boolean inList(DataOrder order)
	{
		for(Entry<String, Map<String, String>> entry : this.filter.entrySet())
		{
			if(entry.getValue().getOrDefault("fieldName", "").equals(order.getFieldName()))
			{
				return true;
			}
		}
		return false;
	}
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/QueryPredicateMapping.java",content:e}]}generatePageUtilFile(){let e=`package ${this.packageName}.utils;

import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;

public class PageUtil {
    
    private PageUtil()
    {
        // Hide public constructor
    }

    /**
     * Creates a Pageable object for paginated and sorted queries.
     *
     * @param pageNumber The 1-based page number. Defaults to 1 if null or less than 1.
     * @param pageSize The number of items per page. Defaults to 20, min is 1.
     * @param sortFields A list of DataOrder objects to sort by.
     * @param map A map to resolve the actual field names from the given keys.
     * @param defaultSortOrder An array of Sort objects to use as the default sort order.
     * @return A Pageable object configured with pagination and sorting.
     */
    public static Pageable pageRequest(Integer pageNumber, Integer pageSize, List<DataOrder> sortFields, Map<String, Map<String, String>> map, Sort... defaultSortOrder) {
        // Handle page number: convert to 0-based and ensure it's not negative.
        int currentPage = (pageNumber != null && pageNumber > 0) ? pageNumber - 1 : 0;
        
        // Handle page size: ensure it's at least 1.
        int rowPerPage = (pageSize != null && pageSize > 0) ? pageSize : 20;
        
        Sort sort = createSortFromList(sortFields, map);

        if (sort.isUnsorted() && defaultSortOrder != null && defaultSortOrder.length > 0) {
            // Correct way to combine multiple Sort objects
            Sort defaultSort = defaultSortOrder[0];
            for (int i = 1; i < defaultSortOrder.length; i++) {
                defaultSort = defaultSort.and(defaultSortOrder[i]);
            }
            sort = defaultSort;
        }
        
        return PageRequest.of(currentPage, rowPerPage, sort);
    }
    
    /**
     * Creates a {@link Sort} object from a list of {@link DataOrder} objects.
     *
     * @param sortFields A list of DataOrder objects, with each object containing "fieldName" and "sortType".
     * @param map A map to resolve the actual field names from the given keys.
     * @return a Sort object representing the combined sorting criteria.
     */
    public static Sort createSortFromList(List<DataOrder> sortFields, Map<String, Map<String, String>> map) {
        if (sortFields == null || sortFields.isEmpty()) {
            return Sort.unsorted();
        }

        List<Order> orders = new ArrayList<>();
        for (DataOrder field : sortFields) {
            String key = field.getFieldName();
            String orderType = field.getOrderType();
            
            // Default to "asc" if no order type is provided
            if (orderType == null) {
                orderType = "asc";
            }

            if (key != null) {
                Map<String, String> orderInfo = map.get(key);
                if (orderInfo != null) {
                    String fieldName = orderInfo.get("fieldName");
                    Direction direction = "desc".equalsIgnoreCase(orderType) ? Direction.DESC : Direction.ASC;
                    orders.add(new Order(direction, fieldName));
                }
            }
        }
        
        if (orders.isEmpty()) {
            return Sort.unsorted();
        }

        return Sort.by(orders);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/PageUtil.java",content:e}]}isForeignKey(e,t,a){if(a.primaryKey)return!1;for(let r of e){if(r.name===t.name)continue;let i=this.getPrimaryKeys(r);for(let n of i)if(n.name===a.name)return!0}return!1}generateIdClassFiles(){let e=[];return this.model.entities.forEach(t=>{let a=this.getPrimaryKeys(t);if(a.length>1){let r=`${stringUtil.upperCamel(stringUtil.camelize(t.name))}Id`,i=`package ${this.packageName}.entity;

import java.io.Serializable;
import java.util.Objects;
import jakarta.persistence.Embeddable;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;

import lombok.Setter;
import lombok.Getter;

@Embeddable
@Setter
@Getter
public class ${r} implements Serializable {

`;a.forEach(e=>{let t=stringUtil.camelize(e.name),a=this.getJavaType(e.type);e.primaryKey&&(i+="",e.autoIncrement&&(i+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),i+=`    private ${a} ${t};

`}),i+=`    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ${r} that = (${r}) o;
        return ${a.map(e=>`Objects.equals(${stringUtil.camelize(e.name)}, that.${stringUtil.camelize(e.name)})`).join(" && ")};
    }

    @Override
    public int hashCode() {
        return Objects.hash(${a.map(e=>stringUtil.camelize(e.name)).join(", ")});
    }

`,i+=`}
`,e.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${r}.java`,content:i})}}),e}generateGraphQlSchema(){return[{name:"src/main/resources/graphql/schema.graphqls",content:util.buildGraphQLSchema(this.model.entities,!1)}]}generatePageInfoFile(){let e=`package ${this.packageName}.utils;

import lombok.Getter;
import lombok.Setter;

import org.springframework.data.domain.Page;

@Setter
@Getter
public class PageInfo {
	Integer totalCount;
    Integer totalPages;
    Integer currentPage;
    Integer pageSize;
    Boolean hasNextPage; 
    Boolean hasPreviousPage;

	public PageInfo(Page<?> page)
	{
		this.totalCount = page.getNumberOfElements();
		this.totalPages = page.getTotalPages();
		this.currentPage = page.getNumber() + 1;
		this.pageSize = page.getSize();
		this.hasNextPage = page.hasNext();
		this.hasPreviousPage = page.hasPrevious();
	}
}



`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/PageInfo.java",content:e}]}generatePomFile(){let e={groupId:this.groupId,artifactId:this.artifactId,version:this.version,name:this.serviceName,description:this.serviceDescription,javaVersion:this.javaVersion,packageName:this.packageName},t=`<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.5.4</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>
<groupId>${e.groupId}</groupId>
<artifactId>${e.artifactId}</artifactId>
<version>${e.version}</version>
<name>${e.name}</name>
<description>${e.description}</description>
<url/>
<licenses>
    <license/>
</licenses>
<developers>
    <developer/>
</developers>
<scm>
    <connection/>
    <developerConnection/>
    <tag/>
    <url/>
</scm>
<properties>
    <java.version>${e.javaVersion}</java.version>
</properties>
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-graphql</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <configuration>
                <annotationProcessorPaths>
                    <path>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                    </path>
                </annotationProcessorPaths>
            </configuration>
        </plugin>
        <plugin>
            <groupId>io.github.deweyjose</groupId>
            <artifactId>graphqlcodegen-maven-plugin</artifactId>
            <version>1.61.5</version>
            <executions>
                <execution>
                    <id>dgs-codegen</id>
                    <goals>
                        <goal>generate</goal>
                    </goals>
                    <configuration>
                        <schemaPaths>
                            <param>src/main/resources/graphql</param>
                        </schemaPaths>
                        <packageName>${e.packageName}.codegen</packageName>
                        <addGeneratedAnnotation>true</addGeneratedAnnotation>
                        <disableDatesInGeneratedAnnotation>true</disableDatesInGeneratedAnnotation>
                    </configuration>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>build-helper-maven-plugin</artifactId>
            <executions>
                <execution>
                    <id>add-dgs-source</id>
                    <phase>generate-sources</phase>
                    <goals>
                        <goal>add-source</goal>
                    </goals>
                    <configuration>
                        <sources>
                            <source>\${project.build.directory}/generated-sources</source>
                        </sources>
                    </configuration>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludes>
                    <exclude>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                    </exclude>
                </excludes>
            </configuration>
        </plugin>
    </plugins>
</build>

</project>
`;return[{name:"pom.xml",content:t}]}getDataType(e){if(null==e)return"String";switch(e.toUpperCase()){case"CHAR":case"VARCHAR":case"TEXT":case"LONGTEXT":case"MEDIUMTEXT":default:return"String";case"TINYINT":case"SMALLINT":case"MEDIUMINT":case"INT":return"Integer";case"BIGINT":return"Long";case"FLOAT":return"Float";case"DOUBLE":case"DECIMAL":return"Double";case"BOOLEAN":return"Boolean";case"DATE":return"Date";case"DATETIME":case"TIMESTAMP":return"DateTime"}}getFilterType(e){return null==e||"String"===e?"partial":"exact"}}