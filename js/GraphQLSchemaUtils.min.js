class GraphQLSchemaUtils{static reservedTypes=["String","Int","Float","Boolean","ID"];static toSnakeCase(e){return e.replace(/([A-Z])/g,(e,t,a)=>(a>0?"_":"")+t.toLowerCase())}static toCamelCase(e){return e.replace(/_([a-z])/g,(e,t)=>t.toUpperCase())}static toUpperCamelCase(e){let t=this.toCamelCase(e);return t.charAt(0).toUpperCase()+t.slice(1)}static normalizeNameForComparison(e){return e.replace(/[_\s]/g,"").toLowerCase()}static normalizeEntity(e,t="snake"){let a={};for(let[n,r]of Object.entries(e)){let i=n;"snake"===t?i.includes("_")||(i=this.toSnakeCase(i)):"camel"===t&&i.includes("_")&&(i=this.toCamelCase(i)),a[i]=r.map(a=>{let{name:n,type:r,nullable:i}=a;if(!this.reservedTypes.includes(r)){let l=r;/id$/i.test(n)||(n=this.normalizeNameForComparison(n)===this.normalizeNameForComparison(l)?n+"Id":n);let o=e[l];if(o){let s=o.find(e=>this.normalizeNameForComparison(e.name)===this.normalizeNameForComparison(n));s&&(r=s.type)}}let m=n.includes("_");return"camel"===t?m&&(n=this.toCamelCase(n)):"snake"===t&&!m&&/[a-z][A-Z]/.test(n)&&(n=this.toSnakeCase(n)),"ID"===r&&(r="String"),{name:n,type:r,nullable:i}})}return a}static parseGraphQLSchema(e){let t={types:{},inputs:{}},a=/(type|input)\s+(\w+)\s*\{([\s\S]*?)\}/g,n;for(;null!==(n=a.exec(e));){let r=n[1],i=n[2],l=n[3];if("Query"===i)continue;let o=[],s=/(\w+):\s*([\w!]+)/g,m;for(;null!==(m=s.exec(l));){let p=m[1],u=m[2],c=u.endsWith("!");c&&(u=u.slice(0,-1)),o.push({name:p,type:u,nullable:!c})}"type"===r?t.types[i]=o:"input"===r&&(t.inputs[i]=o)}return t}static buildGraphQLSchema(e,t=!0,a="offset"){let n={CHAR:"String",VARCHAR:"String",TEXT:"String",LONGTEXT:"String",INT:"Int",INTEGER:"Int",BIGINT:"Int",SMALLINT:"Int",TINYINT:"Boolean",DECIMAL:"Float",NUMERIC:"Float",FLOAT:"Float",DOUBLE:"Float",REAL:"Float",BOOLEAN:"Boolean",DATE:"String",DATETIME:"String",TIMESTAMP:"String",TIME:"String",ENUM:"String",SET:"String"},r=this.toCamelCase,i=this.toUpperCamelCase,l=`# GraphQL Schema generated by GraphQL Generator

`;return"cursor"===a&&(l+=`type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String!
    endCursor: String!
}

`),e.forEach(o=>{let s=i(o.name);l+=`
type ${s} {
`;let m=o.columns.filter(e=>e.primaryKey);if(m.length,o.columns.forEach(a=>{let s=!1,m=!1;if(a.name.endsWith("_id")){let p=a.name.slice(0,-3),u=e.find(e=>e.name.toLowerCase()===p.toLowerCase());if(u&&u.name.toLowerCase()!==o.name.toLowerCase()){let c=i(u.name),g=r(u.name);l+=`    ${g}: ${c}${a.nullable?"":"!"}
`,s=!0}}if(s&&!a.nullable&&(m=!0),a.primaryKey&&(m=!0),a.primaryKey||s||a.nullable||(m=!0),!(t&&s)){let C;C=a.primaryKey?"ID":n[a.type.toUpperCase()]||"String",m&&(C+="!"),l+=`    ${r(a.name)}: ${C}
`}}),l+=`}
`,"cursor"===a){let p=`${s}Connection`,u=`${s}Edge`;l+=`
type ${p} {
    edges: [${u}]
    pageInfo: PageInfo!
}

type ${u} {
    node: ${s}
    cursor: String!
}
`}}),e.forEach(t=>{l+=`
input ${i(t.name)+"Input"} {
`;let a=t.columns.filter(e=>e.primaryKey),o=a.length>1;t.columns.forEach(a=>{let i=a.name.endsWith("_id")&&e.some(e=>e.name.toLowerCase()===a.name.slice(0,-3).toLowerCase()&&e.name.toLowerCase()!==t.name.toLowerCase()),s;s=a.primaryKey||i?"ID":n[a.type.toUpperCase()]||"String";let m=o&&a.primaryKey||i&&!a.nullable||!a.primaryKey&&!i&&!a.nullable;m&&(s+="!"),l+=`    ${r(a.name)}: ${s}
`}),l+=`}
`}),l+=`
input DataFilter{
    fieldName: String,
    fieldValue: String
}
`,l+=`
input DataOrder{
    fieldName: String,
    orderType: String
}
`,l+=`
type Query {
`,e.forEach(e=>{let t=i(e.name),n=r(e.name),o=e.columns.filter(e=>e.primaryKey);if(o.length>0){let s=o.map(e=>{let t=r(e.name);return`${t}: ID`}).join(", "),m=`get${t}`;l+=`    ${m}(${s}): ${t}
`}let p=`${n}s`,u=`get${i(p)}`;"offset"===a?l+=`    ${u}(pageNumber: Int, pageSize: Int, dataFilter: [DataFilter], dataOrder: [DataOrder]): [${t}]
`:"cursor"===a&&(l+=`    ${u}(first: Int, after: String, last: Int, before: String): ${t}Connection
`)}),l+=`}
`,l+=`
type Mutation {
`,e.forEach(e=>{let t=i(e.name);r(e.name);let a=`${t}Input`,n=e.columns.filter(e=>e.primaryKey);if(l+=`    create${t}(input: ${a}!): ${t}
`,l+=`    update${t}(input: ${a}!): ${t}
`,n.length>0){let o=n.map(e=>`${r(e.name)}: ID!`).join(", ");l+=`    delete${t}(${o}): Boolean
`}}),l+=`}
`}}